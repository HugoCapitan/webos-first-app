{"version":3,"sources":["lib/enyo-ilib/ilib/lib/ilib.js","lib/enyo-ilib/ilib/lib/MathUtils.js","lib/enyo-ilib/ilib/lib/JSUtils.js","lib/enyo-ilib/ilib/lib/Locale.js","lib/enyo-ilib/ilib/lib/Utils.js","lib/enyo-ilib/ilib/lib/LocaleInfo.js","lib/enyo-ilib/ilib/lib/IString.js","lib/enyo-ilib/ilib/lib/ResBundle.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACn4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/*\n * ilib.js - define the ilib name space\n * \n * Copyright © 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @namespace The global namespace that contains general ilib functions useful\n * to all of ilib\n * \n * @version // !macro ilibVersion\n */\nvar ilib = ilib || {};\n\n/** @private */\nilib._ver = function() {\n    return // !macro ilibVersion\n    ;\n};\n\n/**\n * Return the current version of ilib.\n * \n * @static\n * @return {string} a version string for this instance of ilib\n */\nilib.getVersion = function () {\n\t// TODO: need some way of getting the version number under dynamic load code\n    return ilib._ver() || \"11.0\"; \n};\n\n/**\n * Place where resources and such are eventually assigned.\n */\nilib.data = {\n\t/** @type {{ccc:Object.<string,number>,nfd:Object.<string,string>,nfc:Object.<string,string>,nfkd:Object.<string,string>,nfkc:Object.<string,string>}} */\n    norm: {\n    \tccc: {},\n    \tnfd: {},\n    \tnfc: {},\n    \tnfkd: {},\n    \tnfkc: {}\n    },\n    zoneinfo: {\n        \"Etc/UTC\":{\"o\":\"0:0\",\"f\":\"UTC\"},\n        \"local\":{\"f\":\"local\"}\n    },\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ ctype: null,\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ ctype_c: null,\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ ctype_l: null,\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ ctype_m: null,\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ ctype_p: null,\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ ctype_z: null,\n    /** @type {null|Object.<string,Array.<Array.<number>>>} */ scriptToRange: null,\n    /** @type {null|Object.<string,string|Object.<string|Object.<string,string>>>} */ dateformats: null,\n    /** @type {null|Array.<string>} */ timezones: []\n};\n\n/*\nif (typeof(window) !== 'undefined') {\n    window[\"ilib\"] = ilib;\n}\n*/\n\n// export ilib for use as a module in nodejs\nif (typeof(module) !== 'undefined') {\n    module.exports = ilib;\n    module.exports.ilib = ilib;  // for backwards compatibility with older versions of ilib\n}\n\n/**\n * Sets the pseudo locale. Pseudolocalization (or pseudo-localization) is used for testing\n * internationalization aspects of software. Instead of translating the text of the software\n * into a foreign language, as in the process of localization, the textual elements of an application\n * are replaced with an altered version of the original language.These specific alterations make\n * the original words appear readable, but include the most problematic characteristics of \n * the world's languages: varying length of text or characters, language direction, and so on.\n * Regular Latin pseudo locale: eu-ES and RTL pseudo locale: ps-AF\n * \n * @param {string|undefined|null} localename the locale specifier for the pseudo locale\n */\nilib.setAsPseudoLocale = function (localename) {\n   if (localename) {\n\t   ilib.pseudoLocales.push(localename)\n   }\n};\n\n/**\n * Reset the list of pseudo locales back to the default single locale of zxx-XX.\n * @static\n */\nilib.clearPseudoLocales = function() {\n\tilib.pseudoLocales = [\n        \"zxx-XX\",\n        \"zxx-Cyrl-XX\",\n        \"zxx-Hans-XX\",\n        \"zxx-Hebr-XX\"\n    ];\n};\n\nilib.clearPseudoLocales();\n\n/**\n * Return the name of the platform\n * @private\n * @static\n * @return {string} string naming the platform\n */\nilib._getPlatform = function () {\n    if (!ilib._platform) {\n    \ttry {\n    \t\tif (typeof(java.lang.Object) !== 'undefined') {\n    \t\t\tilib._platform = (typeof(process) !== 'undefined') ? \"trireme\" : \"rhino\";\n    \t\t\treturn ilib._platform;\n    \t\t}\n    \t} catch (e) {}\n    \t\n        if (typeof(process) !== 'undefined' && typeof(module) !== 'undefined') {\n            ilib._platform = \"nodejs\";\n        } else if (typeof(Qt) !== 'undefined') {\n            ilib._platform = \"qt\";\n        } else if (typeof(window) !== 'undefined') {\n            ilib._platform = (typeof(PalmSystem) !== 'undefined') ? \"webos\" : \"browser\";\n        } else {\n            ilib._platform = \"unknown\";\n        }\n    }    \n    return ilib._platform;\n};\n\n/**\n * If this ilib is running in a browser, return the name of that browser.\n * @private\n * @static\n * @return {string|undefined} the name of the browser that this is running in (\"firefox\", \"chrome\", \"ie\", \n * \"safari\", or \"opera\"), or undefined if this is not running in a browser or if\n * the browser name could not be determined \n */\nilib._getBrowser = function () {\n\tvar browser = undefined;\n\tif (ilib._getPlatform() === \"browser\") {\n\t\tif (navigator && navigator.userAgent) {\n\t\t\tif (navigator.userAgent.indexOf(\"Firefox\") > -1) {\n\t\t\t\tbrowser = \"firefox\";\n\t\t\t}\n\t\t\tif (navigator.userAgent.indexOf(\"Opera\") > -1) {\n\t\t\t\tbrowser = \"opera\";\n\t\t\t}\n\t\t\tif (navigator.userAgent.indexOf(\"Chrome\") > -1) {\n\t\t\t\tbrowser = \"chrome\";\n\t\t\t}\n\t\t\tif (navigator.userAgent.indexOf(\" .NET\") > -1) {\n\t\t\t\tbrowser = \"ie\";\n\t\t\t}\n\t\t\tif (navigator.userAgent.indexOf(\"Safari\") > -1) {\n\t\t\t\t// chrome also has the string Safari in its userAgent, but the chrome case is \n\t\t\t\t// already taken care of above\n\t\t\t\tbrowser = \"safari\";\n\t\t\t}\n\t\t}\n\t}\n\treturn browser;\n};\n\n/**\n * Return true if the global variable is defined on this platform.\n * @private\n * @static\n * @param {string} name the name of the variable to check\n * @return {boolean} true if the global variable is defined on this platform, false otherwise\n */\nilib._isGlobal = function(name) {\n    switch (ilib._getPlatform()) {\n        case \"rhino\":\n            var top = (function() {\n              return (typeof global === 'object') ? global : this;\n            })();\n            return typeof(top[name]) !== 'undefined';\n        case \"nodejs\":\n        case \"trireme\":\n            var root = typeof(global) !== 'undefined' ? global : this;\n            return root && typeof(root[name]) !== 'undefined';\n        case \"qt\":\n        \treturn false;\n        default:\n        \ttry {\n        \t\treturn window && typeof(window[name]) !== 'undefined';\n        \t} catch (e) {\n        \t\treturn false;\n        \t}\n    }\n};\n\n/**\n * Sets the default locale for all of ilib. This locale will be used\n * when no explicit locale is passed to any ilib class. If the default\n * locale is not set, ilib will attempt to use the locale of the\n * environment it is running in, if it can find that. If not, it will\n * default to the locale \"en-US\". If a type of parameter is string, \n * ilib will take only well-formed BCP-47 tag  <p>\n * \n * \n * @static\n * @param {string|undefined|null} spec the locale specifier for the default locale\n */\nilib.setLocale = function (spec) {\n    if (typeof(spec) === 'string' || !spec) {\n        ilib.locale = spec;\n    }\n    // else ignore other data types, as we don't have the dependencies\n    // to look into them to find a locale\n};\n\n/**\n * Return the default locale for all of ilib if one has been set. This \n * locale will be used when no explicit locale is passed to any ilib \n * class. If the default\n * locale is not set, ilib will attempt to use the locale of the\n * environment it is running in, if it can find that. If not, it will\n * default to the locale \"en-US\".<p>\n * \n * \n * @static\n * @return {string} the locale specifier for the default locale\n */\nilib.getLocale = function () {\n    if (typeof(ilib.locale) !== 'string') {\n    \tvar plat = ilib._getPlatform();\n    \tswitch (plat) {\n    \t\tcase 'browser':\n            \t// running in a browser\n                ilib.locale = navigator.language.substring(0,3) + navigator.language.substring(3,5).toUpperCase();  // FF/Opera/Chrome/Webkit\n                if (!ilib.locale) {\n                    // IE on Windows\n                    var lang = typeof(navigator.browserLanguage) !== 'undefined' ? \n                        navigator.browserLanguage :\n                        (typeof(navigator.userLanguage) !== 'undefined' ? \n                            navigator.userLanguage :\n                            (typeof(navigator.systemLanguage) !== 'undefined' ?\n                                navigator.systemLanguage :\n                                undefined));\n                    if (typeof(lang) !== 'undefined' && lang) {\n                        // for some reason, MS uses lower case region tags\n                        ilib.locale = lang.substring(0,3) + lang.substring(3,5).toUpperCase();\n                    }\n                }\n                break;\n    \t\tcase 'webos':\n                // webOS\n                if (typeof(PalmSystem.locales) !== 'undefined' && \n                \t\ttypeof(PalmSystem.locales.UI) != 'undefined' && \n                \t\tPalmSystem.locales.UI.length > 0) {\n                    ilib.locale = PalmSystem.locales.UI;\n                } else if (typeof(PalmSystem.locale) !== 'undefined') {\n                \tilib.locale = PalmSystem.locale;\n                }\n    \t\t\tbreak;\n    \t\tcase 'rhino':\n                if (typeof(environment) !== 'undefined' && environment.user && typeof(environment.user.language) === 'string' && environment.user.language.length > 0) {\n                \t// running under plain rhino\n                    ilib.locale = environment.user.language;\n                    if (typeof(environment.user.country) === 'string' && environment.user.country.length > 0) {\n                        ilib.locale += '-' + environment.user.country;\n                    }\n                }\n                break;\n    \t\tcase \"trireme\":\n            \t// under trireme on rhino emulating nodejs\n            \tvar lang = process.env.LANG || process.env.LANGUAGE || process.env.LC_ALL;\n                // the LANG variable on unix is in the form \"lang_REGION.CHARSET\"\n                // where language and region are the correct ISO codes separated by\n                // an underscore. This translate it back to the BCP-47 form.\n                if (lang && typeof(lang) !== 'undefined') {\n                    ilib.locale = lang.substring(0,2).toLowerCase() + '-' + lang.substring(3,5).toUpperCase();\n                }\n            \tbreak;\n    \t\tcase 'nodejs':\n                // running under nodejs\n                var lang = process.env.LANG || process.env.LC_ALL;\n                // the LANG variable on unix is in the form \"lang_REGION.CHARSET\"\n                // where language and region are the correct ISO codes separated by\n                // an underscore. This translate it back to the BCP-47 form.\n                if (lang && typeof(lang) !== 'undefined') {\n                    ilib.locale = lang.substring(0,2).toLowerCase() + '-' + lang.substring(3,5).toUpperCase();\n                }\n    \t\t\tbreak;\n    \t\tcase 'qt':\n            \t// running in the Javascript engine under Qt/QML\n            \tvar locobj = Qt.locale();\n            \tvar lang = locobj.name && locobj.name.replace(\"_\", \"-\") || \"en-US\";\n    \t\t\tbreak;\n    \t}\n        ilib.locale = typeof(ilib.locale) === 'string' ? ilib.locale : 'en-US';\n    }\n    return ilib.locale;\n};\n\n/**\n * Sets the default time zone for all of ilib. This time zone will be used when\n * no explicit time zone is passed to any ilib class. If the default time zone\n * is not set, ilib will attempt to use the time zone of the\n * environment it is running in, if it can find that. If not, it will\n * default to the the UTC zone \"Etc/UTC\".<p>\n * \n * \n * @static\n * @param {string} tz the name of the time zone to set as the default time zone\n */\nilib.setTimeZone = function (tz) {\n    ilib.tz = tz || ilib.tz;\n};\n\n/**\n * Return the default time zone for all of ilib if one has been set. This \n * time zone will be used when no explicit time zone is passed to any ilib \n * class. If the default time zone\n * is not set, ilib will attempt to use the locale of the\n * environment it is running in, if it can find that. If not, it will\n * default to the the zone \"local\".<p>\n * \n * \n * @static\n * @return {string} the default time zone for ilib\n */\nilib.getTimeZone = function() {\n    if (typeof(ilib.tz) === 'undefined') {\n        if (typeof(navigator) !== 'undefined' && typeof(navigator.timezone) !== 'undefined') {\n            // running in a browser\n            if (navigator.timezone.length > 0) {\n                ilib.tz = navigator.timezone;\n            }\n        } else if (typeof(PalmSystem) !== 'undefined' && typeof(PalmSystem.timezone) !== 'undefined') {\n            // running in webkit on webOS\n            if (PalmSystem.timezone.length > 0) {\n                ilib.tz = PalmSystem.timezone;\n            }\n        } else if (typeof(environment) !== 'undefined' && typeof(environment.user) !== 'undefined') {\n            // running under rhino\n            if (typeof(environment.user.timezone) !== 'undefined' && environment.user.timezone.length > 0) {\n                ilib.tz = environment.user.timezone;\n            }\n        } else if (typeof(process) !== 'undefined' && typeof(process.env) !== 'undefined') {\n            // running in nodejs\n            if (process.env.TZ && typeof(process.env.TZ) !== \"undefined\") {\n                ilib.tz = process.env.TZ;\n            }\n        }\n        \n        ilib.tz = ilib.tz || \"local\"; \n    }\n\n    return ilib.tz;\n};\n\n/**\n * @class\n * Defines the interface for the loader class for ilib. The main method of the\n * loader object is loadFiles(), which loads a set of requested locale data files\n * from where-ever it is stored.\n * @interface\n */\nilib.Loader = function() {};\n\n/**\n * Load a set of files from where-ever it is stored.<p>\n * \n * This is the main function define a callback function for loading missing locale \n * data or resources.\n * If this copy of ilib is assembled without including the required locale data\n * or resources, then that data can be lazy loaded dynamically when it is \n * needed by calling this method. Each ilib class will first\n * check for the existence of data under ilib.data, and if it is not there, \n * it will attempt to load it by calling this method of the laoder, and then place\n * it there.<p>\n * \n * Suggested implementations of this method might load files \n * directly from disk under nodejs or rhino, or within web pages, to load \n * files from the server with XHR calls.<p>\n * \n * The first parameter to this method, paths, is an array of relative paths within \n * the ilib dir structure for the \n * requested data. These paths will already have the locale spec integrated \n * into them, so no further tweaking needs to happen to load the data. Simply\n * load the named files. The second\n * parameter tells the loader whether to load the files synchronously or asynchronously.\n * If the sync parameters is false, then the onLoad function must also be specified.\n * The third parameter gives extra parameters to the loader passed from the calling\n * code. This may contain any property/value pairs.  The last parameter, callback,\n * is a callback function to call when all of the data is finishing loading. Make\n * sure to call the callback with the context of \"this\" so that the caller has their \n * context back again.<p>\n * \n * The loader function must be able to operate either synchronously or asychronously. \n * If the loader function is called with an undefined callback function, it is\n * expected to load the data synchronously, convert it to javascript\n * objects, and return the array of json objects as the return value of the \n * function. If the loader \n * function is called with a callback function, it may load the data \n * synchronously or asynchronously (doesn't matter which) as long as it calls\n * the callback function with the data converted to a javascript objects\n * when it becomes available. If a particular file could not be loaded, the \n * loader function should put undefined into the corresponding entry in the\n * results array. \n * Note that it is important that all the data is loaded before the callback\n * is called.<p>\n * \n * An example implementation for nodejs might be:\n * \n * <pre>\n * var fs = require(\"fs\");\n * \n * var myLoader = function() {};\n * myLoader.prototype = new Loader();\n * myLoader.prototype.constructor = myLoader;\n * myLoader.prototype.loadFiles = function(paths, sync, params, callback) {\n *    if (sync) {\n *        var ret = [];\n *        // synchronous load -- just return the result\n *        paths.forEach(function (path) {\n *            var json = fs.readFileSync(path, \"utf-8\");\n *            ret.push(json ? JSON.parse(json) : undefined);\n *        });\n *        \n *        return ret;\n *    }\n *    this.callback = callback;\n *\n *    // asynchronous\n *    this.results = [];\n *    this._loadFilesAsync(paths);\n * }\n * myLoader.prototype._loadFilesAsync = function (paths) {\n *    if (paths.length > 0) {\n *        var file = paths.shift();\n *        fs.readFile(file, \"utf-8\", function(err, json) {\n *            this.results.push(err ? undefined : JSON.parse(json));\n *            // call self recursively so that the callback is only called at the end\n *            // when all the files are loaded sequentially\n *            if (paths.length > 0) {\n *                this._loadFilesAsync(paths);\n *            } else {\n *                this.callback(this.results);\n *            }\n *        });\n *     }\n * }\n * \n * // bind to \"this\" so that \"this\" is relative to your own instance\n * ilib.setLoaderCallback(new myLoader());\n * </pre>\n\n * @param {Array.<string>} paths An array of paths to load from wherever the files are stored \n * @param {Boolean} sync if true, load the files synchronously, and false means asynchronously\n * @param {Object} params an object with any extra parameters for the loader. These can be \n * anything. The caller of the ilib class passes these parameters in. Presumably, the code that\n * calls ilib and the code that provides the loader are together and can have a private \n * agreement between them about what the parameters should contain.\n * @param {function(Object)} callback function to call when the files are all loaded. The \n * parameter of the callback function is the contents of the files.\n */\nilib.Loader.prototype.loadFiles = function (paths, sync, params, callback) {};\n\n/**\n * Return all files available for loading using this loader instance.\n * This method returns an object where the properties are the paths to\n * directories where files are loaded from and the values are an array\n * of strings containing the relative paths under the directory of each\n * file that can be loaded.<p>\n * \n * Example:\n *  <pre>\n *  {\n *      \"/usr/share/javascript/ilib/locale\": [\n *          \"dateformats.json\",\n *          \"aa/dateformats.json\",\n *          \"af/dateformats.json\",\n *          \"agq/dateformats.json\",\n *          \"ak/dateformats.json\",\n *          ...\n *          \"zxx/dateformats.json\"\n *      ]\n *  }\n *  </pre>\n * @returns {Object} a hash containing directory names and\n * paths to file that can be loaded by this loader \n */\nilib.Loader.prototype.listAvailableFiles = function() {};\n\n/**\n * Return true if the file in the named path is available for loading using\n * this loader. The path may be given as an absolute path, in which case\n * only that file is checked, or as a relative path, in which case, the\n * relative path may appear underneath any of the directories that the loader\n * knows about.\n * @returns {boolean} true if the file in the named path is available for loading, and\n * false otherwise\n */\nilib.Loader.prototype.isAvailable = function(path) {};\n\n/**\n * Set the custom loader used to load ilib's locale data in your environment. \n * The instance passed in must implement the Loader interface. See the\n * Loader class documentation for more information about loaders. \n * \n * @static\n * @param {ilib.Loader} loader class to call to access the requested data.\n * @return {boolean} true if the loader was installed correctly, or false\n * if not\n */\nilib.setLoaderCallback = function(loader) {\n    // only a basic check\n    if ((typeof(loader) === 'object' && typeof(loader.loadFiles) === 'function') || \n            typeof(loader) === 'function' || typeof(loader) === 'undefined') {\n        //console.log(\"setting callback loader to \" + (loader ? loader.name : \"undefined\"));\n        ilib._load = loader;\n        return true;\n    }\n    return false;\n};\n\n/**\n * Return the custom Loader instance currently in use with this instance \n * of ilib. If there is no loader, this method returns undefined.\n * \n * @protected\n * @static\n * @return {ilib.Loader|undefined} the loader instance currently in use, or \n * undefined if there is no such loader\n */\nilib.getLoader = function() {\n\treturn ilib._load;\n};\n\n/**\n * Test whether an object in an javascript array. \n * \n * @static\n * @param {*} object The object to test\n * @return {boolean} return true if the object is an array\n * and false otherwise\n */\nilib.isArray = function(object) {\n\tvar o;\n\tif (typeof(object) === 'object') {\n\t\to = /** @type {Object|null|undefined} */ object;\n\t\treturn Object.prototype.toString.call(o) === '[object Array]';\n\t}\n\treturn false; \n};\n\n/**\n * Extend object1 by mixing in everything from object2 into it. The objects\n * are deeply extended, meaning that this method recursively descends the\n * tree in the objects and mixes them in at each level. Arrays are extended\n * by concatenating the elements of object2 onto those of object1.  \n * \n * @static\n * @param {Object} object1 the target object to extend\n * @param {Object=} object2 the object to mix in to object1\n * @return {Object} returns object1\n */\nilib.extend = function (object1, object2) {\n\tvar prop = undefined;\n\tif (object2) {\n\t\tfor (prop in object2) {\n\t\t\tif (prop && typeof(object2[prop]) !== 'undefined') {\n\t\t\t\tif (ilib.isArray(object1[prop]) && ilib.isArray(object2[prop])) {\n\t\t\t\t\t//console.log(\"Merging array prop \" + prop);\n\t\t\t\t\tobject1[prop] = object1[prop].concat(object2[prop]);\n\t\t\t\t} else if (typeof(object1[prop]) === 'object' && typeof(object2[prop]) === 'object') {\n\t\t\t\t\t//console.log(\"Merging object prop \" + prop);\n\t\t\t\t\tif (prop !== \"ilib\") {\n\t\t\t\t\t\tobject1[prop] = ilib.extend(object1[prop], object2[prop]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//console.log(\"Copying prop \" + prop);\n\t\t\t\t\t// for debugging. Used to determine whether or not json files are overriding their parents unnecessarily\n\t\t\t\t\tobject1[prop] = object2[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn object1;\n};\n\n/**\n * If Function.prototype.bind does not exist in this JS engine, this\n * function reimplements it in terms of older JS functions.\n * bind() doesn't exist in many older browsers.\n * \n * @static\n * @param {Object} scope object that the method should operate on\n * @param {function(...)} method method to call\n * @return {function(...)|undefined} function that calls the given method \n * in the given scope with all of its arguments properly attached, or\n * undefined if there was a problem with the arguments\n */\nilib.bind = function(scope, method/*, bound arguments*/){\n\tif (!scope || !method) {\n\t\treturn undefined;\n\t}\n\t\n\t/** @protected \n\t * @param {Arguments} inArrayLike\n\t * @param {number=} inOffset\n\t */\n\tfunction cloneArray(inArrayLike, inOffset) {\n\t\tvar arr = [];\n\t\tfor(var i = inOffset || 0, l = inArrayLike.length; i<l; i++){\n\t\t\tarr.push(inArrayLike[i]);\n\t\t}\n\t\treturn arr;\n\t}\n\n\tif (typeof(method) === 'function') {\n\t\tvar func, args = cloneArray(arguments, 2);\n\t\tif (typeof(method.bind) === 'function') {\n\t\t\tfunc = method.bind.apply(method, [scope].concat(args));\n\t\t} else {\n\t\t\tfunc = function() {\n\t\t\t\tvar nargs = cloneArray(arguments);\n\t\t\t\t// invoke with collected args\n\t\t\t\treturn method.apply(scope, args.concat(nargs));\n\t\t\t};\n\t\t}\n\t\treturn func;\n\t}\n\treturn undefined;\n};\n\n/**\n * @private\n */\nilib._dyncode = false;\n\n/**\n * Return true if this copy of ilib is using dynamically loaded code. It returns\n * false for pre-assembled code.\n * \n * @static\n * @return {boolean} true if this ilib uses dynamically loaded code, and false otherwise\n */\nilib.isDynCode = function() {\n\treturn ilib._dyncode;\n};\n\n/**\n * @private\n */\nilib._dyndata = false;\n\n/**\n * Return true if this copy of ilib is using dynamically loaded locale data. It returns\n * false for pre-assembled data.\n * \n * @static\n * @return {boolean} true if this ilib uses dynamically loaded locale data, and false otherwise\n */\nilib.isDynData = function() {\n\treturn ilib._dyndata;\n};\n\nilib._loadtime = new Date().getTime();\n","/*\n * MathUtils.js - Misc math utility routines\n * \n * Copyright © 2013-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar MathUtils = {};\n\n/**\n * Return the sign of the given number. If the sign is negative, this function\n * returns -1. If the sign is positive or zero, this function returns 1.\n * @static\n * @param {number} num the number to test\n * @return {number} -1 if the number is negative, and 1 otherwise\n */\nMathUtils.signum = function (num) {\n\tvar n = num;\n\tif (typeof(num) === 'string') {\n\t\tn = parseInt(num, 10);\n\t} else if (typeof(num) !== 'number') {\n\t\treturn 1;\n\t}\n\treturn (n < 0) ? -1 : 1;\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.floor = function (num) {\n\treturn Math.floor(num);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.ceiling = function (num) {\n\treturn Math.ceil(num);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.down = function (num) {\n\treturn (num < 0) ? Math.ceil(num) : Math.floor(num);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.up = function (num) {\n\treturn (num < 0) ? Math.floor(num) : Math.ceil(num);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.halfup = function (num) {\n\treturn (num < 0) ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.halfdown = function (num) {\n\treturn (num < 0) ? Math.floor(num + 0.5) : Math.ceil(num - 0.5);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.halfeven = function (num) {\n\treturn (Math.floor(num) % 2 === 0) ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\nMathUtils.halfodd = function (num) {\n\treturn (Math.floor(num) % 2 !== 0) ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n\n/**\n * Do a proper modulo function. The Javascript % operator will give the truncated\n * division algorithm, but for calendrical calculations, we need the Euclidean\n * division algorithm where the remainder of any division, whether the dividend\n * is negative or not, is always a positive number in the range [0, modulus).<p>\n * \n * \n * @static\n * @param {number} dividend the number being divided\n * @param {number} modulus the number dividing the dividend. This should always be a positive number.\n * @return the remainder of dividing the dividend by the modulus.  \n */\nMathUtils.mod = function (dividend, modulus) {\n\tif (modulus == 0) {\n\t\treturn 0;\n\t}\n\tvar x = dividend % modulus;\n\treturn (x < 0) ? x + modulus : x;\n};\n\n/**\n * Do a proper adjusted modulo function. The Javascript % operator will give the truncated\n * division algorithm, but for calendrical calculations, we need the Euclidean\n * division algorithm where the remainder of any division, whether the dividend\n * is negative or not, is always a positive number in the range (0, modulus]. The adjusted\n * modulo function differs from the regular modulo function in that when the remainder is\n * zero, the modulus should be returned instead.<p>\n * \n * \n * @static\n * @param {number} dividend the number being divided\n * @param {number} modulus the number dividing the dividend. This should always be a positive number.\n * @return the remainder of dividing the dividend by the modulus.  \n */\nMathUtils.amod = function (dividend, modulus) {\n\tif (modulus == 0) {\n\t\treturn 0;\n\t}\n\tvar x = dividend % modulus;\n\treturn (x <= 0) ? x + modulus : x;\n};\n\nmodule.exports = MathUtils;\n","/*\n * JSUtils.js - Misc utilities to work around Javascript engine differences\n * \n * Copyright © 2013-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// !depends ilib.js\n\nvar ilib = require(\"./ilib.js\");\n\nvar JSUtils = {};\n\n/**\n * Perform a shallow copy of the source object to the target object. This only \n * copies the assignments of the source properties to the target properties, \n * but not recursively from there.<p>\n * \n * \n * @static\n * @param {Object} source the source object to copy properties from\n * @param {Object} target the target object to copy properties into\n */\nJSUtils.shallowCopy = function (source, target) {\n\tvar prop = undefined;\n\tif (source && target) {\n\t\tfor (prop in source) {\n\t\t\tif (prop !== undefined && typeof(source[prop]) !== 'undefined') {\n\t\t\t\ttarget[prop] = source[prop];\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Perform a recursive deep copy from the \"from\" object to the \"deep\" object.\n * \n * @static\n * @param {Object} from the object to copy from\n * @param {Object} to the object to copy to\n * @return {Object} a reference to the the \"to\" object\n */\nJSUtils.deepCopy = function(from, to) {\n\tvar prop;\n\n\tfor (prop in from) {\n\t\tif (prop) {\n\t\t\tif (typeof(from[prop]) === 'object') {\n\t\t\t\tto[prop] = {};\n\t\t\t\tJSUtils.deepCopy(from[prop], to[prop]);\n\t\t\t} else {\n\t\t\t\tto[prop] = from[prop];\n\t\t\t}\n\t\t}\n\t}\n\treturn to;\n};\n\n/**\n * Map a string to the given set of alternate characters. If the target set\n * does not contain a particular character in the input string, then that\n * character will be copied to the output unmapped.\n * \n * @static\n * @param {string} str a string to map to an alternate set of characters\n * @param {Array.<string>|Object} map a mapping to alternate characters\n * @return {string} the source string where each character is mapped to alternate characters\n */\nJSUtils.mapString = function (str, map) {\n\tvar mapped = \"\";\n\tif (map && str) {\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\tvar c = str.charAt(i); // TODO use a char iterator?\n\t\t\tmapped += map[c] || c; \n\t\t}\n\t} else {\n\t\tmapped = str;\n\t}\n\treturn mapped;\n};\n\n/**\n * Check if an object is a member of the given array. If this javascript engine\n * support indexOf, it is used directly. Otherwise, this function implements it\n * itself. The idea is to make sure that you can use the quick indexOf if it is\n * available, but use a slower implementation in older engines as well.\n * \n * @static\n * @param {Array.<Object>} array array to search\n * @param {Object} obj object being sought. This should be of the same type as the\n * members of the array being searched. If not, this function will not return\n * any results.\n * @return {number} index of the object in the array, or -1 if it is not in the array.\n */\nJSUtils.indexOf = function(array, obj) {\n\tif (!array || !obj) {\n\t\treturn -1;\n\t}\n\tif (typeof(array.indexOf) === 'function') {\n\t\treturn array.indexOf(obj);\n\t} else {\n\t\tfor (var i = 0; i < array.length; i++) {\n\t        if (array[i] === obj) {\n\t            return i;\n\t        }\n\t    }\n\t    return -1;\n\t}\n};\n\n/**\n * Convert a string into the hexadecimal representation\n * of the Unicode characters in that string.\n * \n * @static\n * @param {string} string The string to convert\n * @param {number=} limit the number of digits to use to represent the character (1 to 8)\n * @return {string} a hexadecimal representation of the\n * Unicode characters in the input string\n */\nJSUtils.toHexString = function(string, limit) {\n\tvar i, \n\t\tresult = \"\", \n\t\tlim = (limit && limit < 9) ? limit : 4;\n\t\n\tif (!string) {\n\t\treturn \"\";\n\t}\n\tfor (i = 0; i < string.length; i++) {\n\t\tvar ch = string.charCodeAt(i).toString(16);\n\t\tresult += \"00000000\".substring(0, lim-ch.length) + ch;\n\t}\n\treturn result.toUpperCase();\n};\n\n/**\n * Test whether an object in a Javascript Date. \n * \n * @static\n * @param {*} object The object to test\n * @return {boolean} return true if the object is a Date\n * and false otherwise\n */\nJSUtils.isDate = function(object) {\n\tvar o;\n\tif (typeof(object) === 'object') {\n\t\to = /** @type {Object|null|undefined} */ object;\n\t\treturn Object.prototype.toString.call(o) === '[object Date]';\n\t}\n\treturn false; \n};\n\n/**\n * Merge the properties of object2 into object1 in a deep manner and return a merged\n * object. If the property exists in both objects, the value in object2 will overwrite \n * the value in object1. If a property exists in object1, but not in object2, its value\n * will not be touched. If a property exists in object2, but not in object1, it will be \n * added to the merged result.<p>\n * \n * Name1 and name2 are for creating debug output only. They are not necessary.<p>\n * \n * \n * @static\n * @param {*} object1 the object to merge into\n * @param {*} object2 the object to merge\n * @param {boolean=} replace if true, replace the array elements in object1 with those in object2.\n * If false, concatenate array elements in object1 with items in object2.\n * @param {string=} name1 name of the object being merged into\n * @param {string=} name2 name of the object being merged in\n * @return {Object} the merged object\n */\nJSUtils.merge = function (object1, object2, replace, name1, name2) {\n\tvar prop = undefined,\n\t\tnewObj = {};\n\tfor (prop in object1) {\n\t\tif (prop && typeof(object1[prop]) !== 'undefined') {\n\t\t\tnewObj[prop] = object1[prop];\n\t\t}\n\t}\n\tfor (prop in object2) {\n\t\tif (prop && typeof(object2[prop]) !== 'undefined') {\n\t\t\tif (ilib.isArray(object1[prop]) && ilib.isArray(object2[prop])) {\n\t\t\t\tif (typeof(replace) !== 'boolean' || !replace) {\n\t\t\t\t\tnewObj[prop] = [].concat(object1[prop]);\n\t\t\t\t\tnewObj[prop] = newObj[prop].concat(object2[prop]);\n\t\t\t\t} else {\n\t\t\t\t\tnewObj[prop] = object2[prop];\n\t\t\t\t}\n\t\t\t} else if (typeof(object1[prop]) === 'object' && typeof(object2[prop]) === 'object') {\n\t\t\t\tnewObj[prop] = JSUtils.merge(object1[prop], object2[prop], replace);\n\t\t\t} else {\n\t\t\t\t// for debugging. Used to determine whether or not json files are overriding their parents unnecessarily\n\t\t\t\tif (name1 && name2 && newObj[prop] == object2[prop]) {\n\t\t\t\t\tconsole.log(\"Property \" + prop + \" in \" + name1 + \" is being overridden by the same value in \" + name2);\n\t\t\t\t}\n\t\t\t\tnewObj[prop] = object2[prop];\n\t\t\t}\n\t\t}\n\t}\n\treturn newObj;\n};\n\n/**\n * Return true if the given object has no properties.<p>\n * \n * \n * @static\n * @param {Object} obj the object to check\n * @return {boolean} true if the given object has no properties, false otherwise\n */\nJSUtils.isEmpty = function (obj) {\n\tvar prop = undefined;\n\t\n\tif (!obj) {\n\t\treturn true;\n\t}\n\t\n\tfor (prop in obj) {\n\t\tif (prop && typeof(obj[prop]) !== 'undefined') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n * @static\n */\nJSUtils.hashCode = function(obj) {\n\tvar hash = 0;\n\t\n\tfunction addHash(hash, newValue) {\n\t\t// co-prime numbers creates a nicely distributed hash\n\t\thash *= 65543;\n\t\thash += newValue;\n\t\thash %= 2147483647; \n\t\treturn hash;\n\t}\n\t\n\tfunction stringHash(str) {\n\t\tvar hash = 0;\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\thash = addHash(hash, str.charCodeAt(i));\n\t\t}\n\t\treturn hash;\n\t}\n\t\n\tswitch (typeof(obj)) {\n\t\tcase 'undefined':\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\tcase 'string':\n\t\t\thash = stringHash(obj);\n\t\t\tbreak;\n\t\tcase 'function':\n\t\tcase 'number':\n\t\tcase 'xml':\n\t\t\thash = stringHash(String(obj));\n\t\t\tbreak;\n\t\tcase 'boolean':\n\t\t\thash = obj ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 'object':\n\t\t\tvar props = [];\n\t\t\tfor (var p in obj) {\n\t\t\t\tif (obj.hasOwnProperty(p)) {\n\t\t\t\t\tprops.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// make sure the order of the properties doesn't matter\n\t\t\tprops.sort();\n\t\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\t\thash = addHash(hash, stringHash(props[i]));\n\t\t\t\thash = addHash(hash, JSUtils.hashCode(obj[props[i]]));\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t\n\treturn hash;\n};\n\n\nmodule.exports = JSUtils;\n","/*\n * Locale.js - Locale specifier definition\n * \n * Copyright © 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// !depends ilib.js JSUtils.js\n\nvar ilib = require(\"./ilib.js\");\nvar JSUtils = require(\"./JSUtils.js\");\n\n/**\n * @class\n * Create a new locale instance. Locales are specified either with a specifier string \n * that follows the BCP-47 convention (roughly: \"language-region-script-variant\") or \n * with 4 parameters that specify the language, region, variant, and script individually.<p>\n * \n * The language is given as an ISO 639-1 two-letter, lower-case language code. You\n * can find a full list of these codes at \n * <a href=\"http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes</a><p>\n * \n * The region is given as an ISO 3166-1 two-letter, upper-case region code. You can\n * find a full list of these codes at \n * <a href=\"http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\">http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2</a>.<p>\n * \n * The variant is any string that does not contain a dash which further differentiates\n * locales from each other.<p>\n * \n * The script is given as the ISO 15924 four-letter script code. In some locales,\n * text may be validly written in more than one script. For example, Serbian is often\n * written in both Latin and Cyrillic, though not usually mixed together. You can find a\n * full list of these codes at \n * <a href=\"http://en.wikipedia.org/wiki/ISO_15924#List_of_codes\">http://en.wikipedia.org/wiki/ISO_15924#List_of_codes</a>.<p>\n * \n * As an example in ilib, the script can be used in the date formatter. Dates formatted \n * in Serbian could have day-of-week names or month names written in the Latin\n * or Cyrillic script. Often one script is default such that sr-SR-Latn is the same\n * as sr-SR so the script code \"Latn\" can be left off of the locale spec.<p> \n * \n * Each part is optional, and an empty string in the specifier before or after a \n * dash or as a parameter to the constructor denotes an unspecified value. In this\n * case, many of the ilib functions will treat the locale as generic. For example\n * the locale \"en-\" is equivalent to \"en\" and to \"en--\" and denotes a locale\n * of \"English\" with an unspecified region and variant, which typically matches\n * any region or variant.<p>\n * \n * Without any arguments to the constructor, this function returns the locale of\n * the host Javascript engine.<p>\n * \n * \n * @constructor\n * @param {?string|Locale=} language the ISO 639 2-letter code for the language, or a full \n * locale spec in BCP-47 format, or another Locale instance to copy from\n * @param {string=} region the ISO 3166 2-letter code for the region\n * @param {string=} variant the name of the variant of this locale, if any\n * @param {string=} script the ISO 15924 code of the script for this locale, if any\n */\nvar Locale = function(language, region, variant, script) {\n\tif (typeof(region) === 'undefined') {\n\t\tvar spec = language || ilib.getLocale();\n\t\tif (typeof(spec) === 'string') {\n\t\t\tvar parts = spec.split('-');\n\t        for ( var i = 0; i < parts.length; i++ ) {\n\t        \tif (Locale._isLanguageCode(parts[i])) {\n\t    \t\t\t/** \n\t    \t\t\t * @private\n\t    \t\t\t * @type {string|undefined}\n\t    \t\t\t */\n\t        \t\tthis.language = parts[i];\n\t        \t} else if (Locale._isRegionCode(parts[i])) {\n\t    \t\t\t/** \n\t    \t\t\t * @private\n\t    \t\t\t * @type {string|undefined}\n\t    \t\t\t */\n\t        \t\tthis.region = parts[i];\n\t        \t} else if (Locale._isScriptCode(parts[i])) {\n\t    \t\t\t/** \n\t    \t\t\t * @private\n\t    \t\t\t * @type {string|undefined}\n\t    \t\t\t */\n\t        \t\tthis.script = parts[i];\n\t        \t} else {\n\t    \t\t\t/** \n\t    \t\t\t * @private\n\t    \t\t\t * @type {string|undefined}\n\t    \t\t\t */\n\t        \t\tthis.variant = parts[i];\n\t        \t}\n\t        }\n\t        this.language = this.language || undefined;\n\t        this.region = this.region || undefined;\n\t        this.script = this.script || undefined;\n\t        this.variant = this.variant || undefined;\n\t\t} else if (typeof(spec) === 'object') {\n\t        this.language = spec.language || undefined;\n\t        this.region = spec.region || undefined;\n\t        this.script = spec.script || undefined;\n\t        this.variant = spec.variant || undefined;\n\t\t}\n\t} else {\n\t\tif (language) {\n\t\t\tlanguage = language.trim();\n\t\t\tthis.language = language.length > 0 ? language.toLowerCase() : undefined;\n\t\t} else {\n\t\t\tthis.language = undefined;\n\t\t}\n\t\tif (region) {\n\t\t\tregion = region.trim();\n\t\t\tthis.region = region.length > 0 ? region.toUpperCase() : undefined;\n\t\t} else {\n\t\t\tthis.region = undefined;\n\t\t}\n\t\tif (variant) {\n\t\t\tvariant = variant.trim();\n\t\t\tthis.variant = variant.length > 0 ? variant : undefined;\n\t\t} else {\n\t\t\tthis.variant = undefined;\n\t\t}\n\t\tif (script) {\n\t\t\tscript = script.trim();\n\t\t\tthis.script = script.length > 0 ? script : undefined;\n\t\t} else {\n\t\t\tthis.script = undefined;\n\t\t}\n\t}\n\tthis._genSpec();\n};\n\n// from http://en.wikipedia.org/wiki/ISO_3166-1\nLocale.a2toa3regmap = {\n\t\"AF\": \"AFG\",\n\t\"AX\": \"ALA\",\n\t\"AL\": \"ALB\",\n\t\"DZ\": \"DZA\",\n\t\"AS\": \"ASM\",\n\t\"AD\": \"AND\",\n\t\"AO\": \"AGO\",\n\t\"AI\": \"AIA\",\n\t\"AQ\": \"ATA\",\n\t\"AG\": \"ATG\",\n\t\"AR\": \"ARG\",\n\t\"AM\": \"ARM\",\n\t\"AW\": \"ABW\",\n\t\"AU\": \"AUS\",\n\t\"AT\": \"AUT\",\n\t\"AZ\": \"AZE\",\n\t\"BS\": \"BHS\",\n\t\"BH\": \"BHR\",\n\t\"BD\": \"BGD\",\n\t\"BB\": \"BRB\",\n\t\"BY\": \"BLR\",\n\t\"BE\": \"BEL\",\n\t\"BZ\": \"BLZ\",\n\t\"BJ\": \"BEN\",\n\t\"BM\": \"BMU\",\n\t\"BT\": \"BTN\",\n\t\"BO\": \"BOL\",\n\t\"BQ\": \"BES\",\n\t\"BA\": \"BIH\",\n\t\"BW\": \"BWA\",\n\t\"BV\": \"BVT\",\n\t\"BR\": \"BRA\",\n\t\"IO\": \"IOT\",\n\t\"BN\": \"BRN\",\n\t\"BG\": \"BGR\",\n\t\"BF\": \"BFA\",\n\t\"BI\": \"BDI\",\n\t\"KH\": \"KHM\",\n\t\"CM\": \"CMR\",\n\t\"CA\": \"CAN\",\n\t\"CV\": \"CPV\",\n\t\"KY\": \"CYM\",\n\t\"CF\": \"CAF\",\n\t\"TD\": \"TCD\",\n\t\"CL\": \"CHL\",\n\t\"CN\": \"CHN\",\n\t\"CX\": \"CXR\",\n\t\"CC\": \"CCK\",\n\t\"CO\": \"COL\",\n\t\"KM\": \"COM\",\n\t\"CG\": \"COG\",\n\t\"CD\": \"COD\",\n\t\"CK\": \"COK\",\n\t\"CR\": \"CRI\",\n\t\"CI\": \"CIV\",\n\t\"HR\": \"HRV\",\n\t\"CU\": \"CUB\",\n\t\"CW\": \"CUW\",\n\t\"CY\": \"CYP\",\n\t\"CZ\": \"CZE\",\n\t\"DK\": \"DNK\",\n\t\"DJ\": \"DJI\",\n\t\"DM\": \"DMA\",\n\t\"DO\": \"DOM\",\n\t\"EC\": \"ECU\",\n\t\"EG\": \"EGY\",\n\t\"SV\": \"SLV\",\n\t\"GQ\": \"GNQ\",\n\t\"ER\": \"ERI\",\n\t\"EE\": \"EST\",\n\t\"ET\": \"ETH\",\n\t\"FK\": \"FLK\",\n\t\"FO\": \"FRO\",\n\t\"FJ\": \"FJI\",\n\t\"FI\": \"FIN\",\n\t\"FR\": \"FRA\",\n\t\"GF\": \"GUF\",\n\t\"PF\": \"PYF\",\n\t\"TF\": \"ATF\",\n\t\"GA\": \"GAB\",\n\t\"GM\": \"GMB\",\n\t\"GE\": \"GEO\",\n\t\"DE\": \"DEU\",\n\t\"GH\": \"GHA\",\n\t\"GI\": \"GIB\",\n\t\"GR\": \"GRC\",\n\t\"GL\": \"GRL\",\n\t\"GD\": \"GRD\",\n\t\"GP\": \"GLP\",\n\t\"GU\": \"GUM\",\n\t\"GT\": \"GTM\",\n\t\"GG\": \"GGY\",\n\t\"GN\": \"GIN\",\n\t\"GW\": \"GNB\",\n\t\"GY\": \"GUY\",\n\t\"HT\": \"HTI\",\n\t\"HM\": \"HMD\",\n\t\"VA\": \"VAT\",\n\t\"HN\": \"HND\",\n\t\"HK\": \"HKG\",\n\t\"HU\": \"HUN\",\n\t\"IS\": \"ISL\",\n\t\"IN\": \"IND\",\n\t\"ID\": \"IDN\",\n\t\"IR\": \"IRN\",\n\t\"IQ\": \"IRQ\",\n\t\"IE\": \"IRL\",\n\t\"IM\": \"IMN\",\n\t\"IL\": \"ISR\",\n\t\"IT\": \"ITA\",\n\t\"JM\": \"JAM\",\n\t\"JP\": \"JPN\",\n\t\"JE\": \"JEY\",\n\t\"JO\": \"JOR\",\n\t\"KZ\": \"KAZ\",\n\t\"KE\": \"KEN\",\n\t\"KI\": \"KIR\",\n\t\"KP\": \"PRK\",\n\t\"KR\": \"KOR\",\n\t\"KW\": \"KWT\",\n\t\"KG\": \"KGZ\",\n\t\"LA\": \"LAO\",\n\t\"LV\": \"LVA\",\n\t\"LB\": \"LBN\",\n\t\"LS\": \"LSO\",\n\t\"LR\": \"LBR\",\n\t\"LY\": \"LBY\",\n\t\"LI\": \"LIE\",\n\t\"LT\": \"LTU\",\n\t\"LU\": \"LUX\",\n\t\"MO\": \"MAC\",\n\t\"MK\": \"MKD\",\n\t\"MG\": \"MDG\",\n\t\"MW\": \"MWI\",\n\t\"MY\": \"MYS\",\n\t\"MV\": \"MDV\",\n\t\"ML\": \"MLI\",\n\t\"MT\": \"MLT\",\n\t\"MH\": \"MHL\",\n\t\"MQ\": \"MTQ\",\n\t\"MR\": \"MRT\",\n\t\"MU\": \"MUS\",\n\t\"YT\": \"MYT\",\n\t\"MX\": \"MEX\",\n\t\"FM\": \"FSM\",\n\t\"MD\": \"MDA\",\n\t\"MC\": \"MCO\",\n\t\"MN\": \"MNG\",\n\t\"ME\": \"MNE\",\n\t\"MS\": \"MSR\",\n\t\"MA\": \"MAR\",\n\t\"MZ\": \"MOZ\",\n\t\"MM\": \"MMR\",\n\t\"NA\": \"NAM\",\n\t\"NR\": \"NRU\",\n\t\"NP\": \"NPL\",\n\t\"NL\": \"NLD\",\n\t\"NC\": \"NCL\",\n\t\"NZ\": \"NZL\",\n\t\"NI\": \"NIC\",\n\t\"NE\": \"NER\",\n\t\"NG\": \"NGA\",\n\t\"NU\": \"NIU\",\n\t\"NF\": \"NFK\",\n\t\"MP\": \"MNP\",\n\t\"NO\": \"NOR\",\n\t\"OM\": \"OMN\",\n\t\"PK\": \"PAK\",\n\t\"PW\": \"PLW\",\n\t\"PS\": \"PSE\",\n\t\"PA\": \"PAN\",\n\t\"PG\": \"PNG\",\n\t\"PY\": \"PRY\",\n\t\"PE\": \"PER\",\n\t\"PH\": \"PHL\",\n\t\"PN\": \"PCN\",\n\t\"PL\": \"POL\",\n\t\"PT\": \"PRT\",\n\t\"PR\": \"PRI\",\n\t\"QA\": \"QAT\",\n\t\"RE\": \"REU\",\n\t\"RO\": \"ROU\",\n\t\"RU\": \"RUS\",\n\t\"RW\": \"RWA\",\n\t\"BL\": \"BLM\",\n\t\"SH\": \"SHN\",\n\t\"KN\": \"KNA\",\n\t\"LC\": \"LCA\",\n\t\"MF\": \"MAF\",\n\t\"PM\": \"SPM\",\n\t\"VC\": \"VCT\",\n\t\"WS\": \"WSM\",\n\t\"SM\": \"SMR\",\n\t\"ST\": \"STP\",\n\t\"SA\": \"SAU\",\n\t\"SN\": \"SEN\",\n\t\"RS\": \"SRB\",\n\t\"SC\": \"SYC\",\n\t\"SL\": \"SLE\",\n\t\"SG\": \"SGP\",\n\t\"SX\": \"SXM\",\n\t\"SK\": \"SVK\",\n\t\"SI\": \"SVN\",\n\t\"SB\": \"SLB\",\n\t\"SO\": \"SOM\",\n\t\"ZA\": \"ZAF\",\n\t\"GS\": \"SGS\",\n\t\"SS\": \"SSD\",\n\t\"ES\": \"ESP\",\n\t\"LK\": \"LKA\",\n\t\"SD\": \"SDN\",\n\t\"SR\": \"SUR\",\n\t\"SJ\": \"SJM\",\n\t\"SZ\": \"SWZ\",\n\t\"SE\": \"SWE\",\n\t\"CH\": \"CHE\",\n\t\"SY\": \"SYR\",\n\t\"TW\": \"TWN\",\n\t\"TJ\": \"TJK\",\n\t\"TZ\": \"TZA\",\n\t\"TH\": \"THA\",\n\t\"TL\": \"TLS\",\n\t\"TG\": \"TGO\",\n\t\"TK\": \"TKL\",\n\t\"TO\": \"TON\",\n\t\"TT\": \"TTO\",\n\t\"TN\": \"TUN\",\n\t\"TR\": \"TUR\",\n\t\"TM\": \"TKM\",\n\t\"TC\": \"TCA\",\n\t\"TV\": \"TUV\",\n\t\"UG\": \"UGA\",\n\t\"UA\": \"UKR\",\n\t\"AE\": \"ARE\",\n\t\"GB\": \"GBR\",\n\t\"US\": \"USA\",\n\t\"UM\": \"UMI\",\n\t\"UY\": \"URY\",\n\t\"UZ\": \"UZB\",\n\t\"VU\": \"VUT\",\n\t\"VE\": \"VEN\",\n\t\"VN\": \"VNM\",\n\t\"VG\": \"VGB\",\n\t\"VI\": \"VIR\",\n\t\"WF\": \"WLF\",\n\t\"EH\": \"ESH\",\n\t\"YE\": \"YEM\",\n\t\"ZM\": \"ZMB\",\n\t\"ZW\": \"ZWE\"\n};\n\n\nLocale.a1toa3langmap = {\n\t\"ab\": \"abk\",\n\t\"aa\": \"aar\",\n\t\"af\": \"afr\",\n\t\"ak\": \"aka\",\n\t\"sq\": \"sqi\",\n\t\"am\": \"amh\",\n\t\"ar\": \"ara\",\n\t\"an\": \"arg\",\n\t\"hy\": \"hye\",\n\t\"as\": \"asm\",\n\t\"av\": \"ava\",\n\t\"ae\": \"ave\",\n\t\"ay\": \"aym\",\n\t\"az\": \"aze\",\n\t\"bm\": \"bam\",\n\t\"ba\": \"bak\",\n\t\"eu\": \"eus\",\n\t\"be\": \"bel\",\n\t\"bn\": \"ben\",\n\t\"bh\": \"bih\",\n\t\"bi\": \"bis\",\n\t\"bs\": \"bos\",\n\t\"br\": \"bre\",\n\t\"bg\": \"bul\",\n\t\"my\": \"mya\",\n\t\"ca\": \"cat\",\n\t\"ch\": \"cha\",\n\t\"ce\": \"che\",\n\t\"ny\": \"nya\",\n\t\"zh\": \"zho\",\n\t\"cv\": \"chv\",\n\t\"kw\": \"cor\",\n\t\"co\": \"cos\",\n\t\"cr\": \"cre\",\n\t\"hr\": \"hrv\",\n\t\"cs\": \"ces\",\n\t\"da\": \"dan\",\n\t\"dv\": \"div\",\n\t\"nl\": \"nld\",\n\t\"dz\": \"dzo\",\n\t\"en\": \"eng\",\n\t\"eo\": \"epo\",\n\t\"et\": \"est\",\n\t\"ee\": \"ewe\",\n\t\"fo\": \"fao\",\n\t\"fj\": \"fij\",\n\t\"fi\": \"fin\",\n\t\"fr\": \"fra\",\n\t\"ff\": \"ful\",\n\t\"gl\": \"glg\",\n\t\"ka\": \"kat\",\n\t\"de\": \"deu\",\n\t\"el\": \"ell\",\n\t\"gn\": \"grn\",\n\t\"gu\": \"guj\",\n\t\"ht\": \"hat\",\n\t\"ha\": \"hau\",\n\t\"he\": \"heb\",\n\t\"hz\": \"her\",\n\t\"hi\": \"hin\",\n\t\"ho\": \"hmo\",\n\t\"hu\": \"hun\",\n\t\"ia\": \"ina\",\n\t\"id\": \"ind\",\n\t\"ie\": \"ile\",\n\t\"ga\": \"gle\",\n\t\"ig\": \"ibo\",\n\t\"ik\": \"ipk\",\n\t\"io\": \"ido\",\n\t\"is\": \"isl\",\n\t\"it\": \"ita\",\n\t\"iu\": \"iku\",\n\t\"ja\": \"jpn\",\n\t\"jv\": \"jav\",\n\t\"kl\": \"kal\",\n\t\"kn\": \"kan\",\n\t\"kr\": \"kau\",\n\t\"ks\": \"kas\",\n\t\"kk\": \"kaz\",\n\t\"km\": \"khm\",\n\t\"ki\": \"kik\",\n\t\"rw\": \"kin\",\n\t\"ky\": \"kir\",\n\t\"kv\": \"kom\",\n\t\"kg\": \"kon\",\n\t\"ko\": \"kor\",\n\t\"ku\": \"kur\",\n\t\"kj\": \"kua\",\n\t\"la\": \"lat\",\n\t\"lb\": \"ltz\",\n\t\"lg\": \"lug\",\n\t\"li\": \"lim\",\n\t\"ln\": \"lin\",\n\t\"lo\": \"lao\",\n\t\"lt\": \"lit\",\n\t\"lu\": \"lub\",\n\t\"lv\": \"lav\",\n\t\"gv\": \"glv\",\n\t\"mk\": \"mkd\",\n\t\"mg\": \"mlg\",\n\t\"ms\": \"msa\",\n\t\"ml\": \"mal\",\n\t\"mt\": \"mlt\",\n\t\"mi\": \"mri\",\n\t\"mr\": \"mar\",\n\t\"mh\": \"mah\",\n\t\"mn\": \"mon\",\n\t\"na\": \"nau\",\n\t\"nv\": \"nav\",\n\t\"nb\": \"nob\",\n\t\"nd\": \"nde\",\n\t\"ne\": \"nep\",\n\t\"ng\": \"ndo\",\n\t\"nn\": \"nno\",\n\t\"no\": \"nor\",\n\t\"ii\": \"iii\",\n\t\"nr\": \"nbl\",\n\t\"oc\": \"oci\",\n\t\"oj\": \"oji\",\n\t\"cu\": \"chu\",\n\t\"om\": \"orm\",\n\t\"or\": \"ori\",\n\t\"os\": \"oss\",\n\t\"pa\": \"pan\",\n\t\"pi\": \"pli\",\n\t\"fa\": \"fas\",\n\t\"pl\": \"pol\",\n\t\"ps\": \"pus\",\n\t\"pt\": \"por\",\n\t\"qu\": \"que\",\n\t\"rm\": \"roh\",\n\t\"rn\": \"run\",\n\t\"ro\": \"ron\",\n\t\"ru\": \"rus\",\n\t\"sa\": \"san\",\n\t\"sc\": \"srd\",\n\t\"sd\": \"snd\",\n\t\"se\": \"sme\",\n\t\"sm\": \"smo\",\n\t\"sg\": \"sag\",\n\t\"sr\": \"srp\",\n\t\"gd\": \"gla\",\n\t\"sn\": \"sna\",\n\t\"si\": \"sin\",\n\t\"sk\": \"slk\",\n\t\"sl\": \"slv\",\n\t\"so\": \"som\",\n\t\"st\": \"sot\",\n\t\"es\": \"spa\",\n\t\"su\": \"sun\",\n\t\"sw\": \"swa\",\n\t\"ss\": \"ssw\",\n\t\"sv\": \"swe\",\n\t\"ta\": \"tam\",\n\t\"te\": \"tel\",\n\t\"tg\": \"tgk\",\n\t\"th\": \"tha\",\n\t\"ti\": \"tir\",\n\t\"bo\": \"bod\",\n\t\"tk\": \"tuk\",\n\t\"tl\": \"tgl\",\n\t\"tn\": \"tsn\",\n\t\"to\": \"ton\",\n\t\"tr\": \"tur\",\n\t\"ts\": \"tso\",\n\t\"tt\": \"tat\",\n\t\"tw\": \"twi\",\n\t\"ty\": \"tah\",\n\t\"ug\": \"uig\",\n\t\"uk\": \"ukr\",\n\t\"ur\": \"urd\",\n\t\"uz\": \"uzb\",\n\t\"ve\": \"ven\",\n\t\"vi\": \"vie\",\n\t\"vo\": \"vol\",\n\t\"wa\": \"wln\",\n\t\"cy\": \"cym\",\n\t\"wo\": \"wol\",\n\t\"fy\": \"fry\",\n\t\"xh\": \"xho\",\n\t\"yi\": \"yid\",\n\t\"yo\": \"yor\",\n\t\"za\": \"zha\",\n\t\"zu\": \"zul\"\n};\n\n/**\n * Tell whether or not the str does not start with a lower case ASCII char.\n * @private\n * @param {string} str the char to check\n * @return {boolean} true if the char is not a lower case ASCII char\n */\nLocale._notLower = function(str) {\n\t// do this with ASCII only so we don't have to depend on the CType functions\n\tvar ch = str.charCodeAt(0);\n\treturn ch < 97 || ch > 122;\n};\n\n/**\n * Tell whether or not the str does not start with an upper case ASCII char.\n * @private\n * @param {string} str the char to check\n * @return {boolean} true if the char is a not an upper case ASCII char\n */\nLocale._notUpper = function(str) {\n\t// do this with ASCII only so we don't have to depend on the CType functions\n\tvar ch = str.charCodeAt(0);\n\treturn ch < 65 || ch > 90;\n};\n\n/**\n * Tell whether or not the str does not start with a digit char.\n * @private\n * @param {string} str the char to check\n * @return {boolean} true if the char is a not an upper case ASCII char\n */\nLocale._notDigit = function(str) {\n\t// do this with ASCII only so we don't have to depend on the CType functions\n\tvar ch = str.charCodeAt(0);\n\treturn ch < 48 || ch > 57;\n};\n\n/**\n * Tell whether or not the given string has the correct syntax to be \n * an ISO 639 language code.\n * \n * @private\n * @param {string} str the string to parse\n * @return {boolean} true if the string could syntactically be a language code.\n */\nLocale._isLanguageCode = function(str) {\n\tif (typeof(str) === 'undefined' || str.length < 2 || str.length > 3) {\n\t\treturn false;\n\t}\n\n\tfor (var i = 0; i < str.length; i++) {\n\t\tif (Locale._notLower(str.charAt(i))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n};\n\n/**\n * Tell whether or not the given string has the correct syntax to be \n * an ISO 3166 2-letter region code or M.49 3-digit region code.\n * \n * @private\n * @param {string} str the string to parse\n * @return {boolean} true if the string could syntactically be a language code.\n */\nLocale._isRegionCode = function (str) {\n\tif (typeof(str) === 'undefined' || str.length < 2 || str.length > 3) {\n\t\treturn false;\n\t}\n\t\n\tif (str.length === 2) {\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\tif (Locale._notUpper(str.charAt(i))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\tif (Locale._notDigit(str.charAt(i))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n};\n\n/**\n * Tell whether or not the given string has the correct syntax to be \n * an ISO 639 language code.\n * \n * @private\n * @param {string} str the string to parse\n * @return {boolean} true if the string could syntactically be a language code.\n */\nLocale._isScriptCode = function(str) {\n\tif (typeof(str) === 'undefined' || str.length !== 4 || Locale._notUpper(str.charAt(0))) {\n\t\treturn false;\n\t}\n\t\n\tfor (var i = 1; i < 4; i++) {\n\t\tif (Locale._notLower(str.charAt(i))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n};\n\n/**\n * Return the ISO-3166 alpha3 equivalent region code for the given ISO 3166 alpha2\n * region code. If the given alpha2 code is not found, this function returns its\n * argument unchanged.\n * @static\n * @param {string|undefined} alpha2 the alpha2 code to map\n * @return {string|undefined} the alpha3 equivalent of the given alpha2 code, or the alpha2\n * parameter if the alpha2 value is not found\n */\nLocale.regionAlpha2ToAlpha3 = function(alpha2) {\n\treturn Locale.a2toa3regmap[alpha2] || alpha2;\n};\n\n/**\n * Return the ISO-639 alpha3 equivalent language code for the given ISO 639 alpha1\n * language code. If the given alpha1 code is not found, this function returns its\n * argument unchanged.\n * @static\n * @param {string|undefined} alpha1 the alpha1 code to map\n * @return {string|undefined} the alpha3 equivalent of the given alpha1 code, or the alpha1\n * parameter if the alpha1 value is not found\n */\nLocale.languageAlpha1ToAlpha3 = function(alpha1) {\n\treturn Locale.a1toa3langmap[alpha1] || alpha1;\n};\n\nLocale.prototype = {\n\t/**\n\t * @private\n\t */\n\t_genSpec: function () {\n\t\tthis.spec = this.language || \"\";\n\t\t\n\t\tif (this.script) {\n\t\t\tif (this.spec.length > 0) {\n\t\t\t\tthis.spec += \"-\";\n\t\t\t}\n\t\t\tthis.spec += this.script;\n\t\t}\n\t\t\n\t\tif (this.region) {\n\t\t\tif (this.spec.length > 0) {\n\t\t\t\tthis.spec += \"-\";\n\t\t\t}\n\t\t\tthis.spec += this.region;\n\t\t}\n\t\t\n\t\tif (this.variant) {\n\t\t\tif (this.spec.length > 0) {\n\t\t\t\tthis.spec += \"-\";\n\t\t\t}\n\t\t\tthis.spec += this.variant;\n\t\t}\n\t},\n\n\t/**\n\t * Return the ISO 639 language code for this locale. \n\t * @return {string|undefined} the language code for this locale \n\t */\n\tgetLanguage: function() {\n\t\treturn this.language;\n\t},\n\t\n\t/**\n\t * Return the language of this locale as an ISO-639-alpha3 language code\n\t * @return {string|undefined} the alpha3 language code of this locale\n\t */\n\tgetLanguageAlpha3: function() {\n\t\treturn Locale.languageAlpha1ToAlpha3(this.language);\n\t},\n\t\n\t/**\n\t * Return the ISO 3166 region code for this locale.\n\t * @return {string|undefined} the region code of this locale\n\t */\n\tgetRegion: function() {\n\t\treturn this.region;\n\t},\n\t\n\t/**\n\t * Return the region of this locale as an ISO-3166-alpha3 region code\n\t * @return {string|undefined} the alpha3 region code of this locale\n\t */\n\tgetRegionAlpha3: function() {\n\t\treturn Locale.regionAlpha2ToAlpha3(this.region);\n\t},\n\t\n\t/**\n\t * Return the ISO 15924 script code for this locale\n\t * @return {string|undefined} the script code of this locale\n\t */\n\tgetScript: function () {\n\t\treturn this.script;\n\t},\n\t\n\t/**\n\t * Return the variant code for this locale\n\t * @return {string|undefined} the variant code of this locale, if any\n\t */\n\tgetVariant: function() {\n\t\treturn this.variant;\n\t},\n\t\n\t/**\n\t * Return the whole locale specifier as a string.\n\t * @return {string} the locale specifier\n\t */\n\tgetSpec: function() {\n\t\treturn this.spec;\n\t},\n\t\n\t/**\n\t * Express this locale object as a string. Currently, this simply calls the getSpec\n\t * function to represent the locale as its specifier.\n\t * \n\t * @return {string} the locale specifier\n\t */\n\ttoString: function() {\n\t\treturn this.getSpec();\n\t},\n\t\n\t/**\n\t * Return true if the the other locale is exactly equal to the current one.\n\t * @return {boolean} whether or not the other locale is equal to the current one \n\t */\n\tequals: function(other) {\n\t\treturn this.language === other.language &&\n\t\t\tthis.region === other.region &&\n\t\t\tthis.script === other.script &&\n\t\t\tthis.variant === other.variant;\n\t},\n\n\t/**\n\t * Return true if the current locale is the special pseudo locale.\n\t * @return {boolean} true if the current locale is the special pseudo locale\n\t */\n\tisPseudo: function () {\n\t\treturn JSUtils.indexOf(ilib.pseudoLocales, this.spec) > -1;\n\t}\n};\n\n// static functions\n/**\n * @private\n */\nLocale.locales = [\n\t// !macro localelist\n];\n\n/**\n * Return the list of available locales that this iLib file supports.\n * If this copy of ilib is pre-assembled with locale data, then the \n * list locales may be much smaller\n * than the list of all available locales in the iLib repository. The\n * assembly tool will automatically fill in the list for an assembled\n * copy of iLib. If this copy is being used with dynamically loaded \n * data, then you \n * can load any locale that iLib supports. You can form a locale with any \n * combination of a language and region tags that exist in the locale\n * data directory. Language tags are in the root of the locale data dir,\n * and region tags can be found underneath the \"und\" directory. (The \n * region tags are separated into a different dir because the region names \n * conflict with language names on file systems that are case-insensitive.) \n * If you have culled the locale data directory to limit the size of\n * your app, then this function should return only those files that actually exist\n * according to the ilibmanifest.json file in the root of that locale\n * data dir. Make sure your ilibmanifest.json file is up-to-date with\n * respect to the list of files that exist in the locale data dir.\n * \n * @param {boolean} sync if false, load the list of available files from disk\n * asynchronously, otherwise load them synchronously. (Default: true/synchronously)\n * @param {Function} onLoad a callback function to call if asynchronous\n * load was requested and the list of files have been loaded.\n * @return {Array.<string>} this is an array of locale specs for which \n * this iLib file has locale data for\n */\nLocale.getAvailableLocales = function (sync, onLoad) {\n\tvar locales = [];\n\tif (Locale.locales.length || typeof(ilib._load.listAvailableFiles) !== 'function') {\n\t\tlocales = Locale.locales;\n\t\tif (onLoad && typeof(onLoad) === 'function') {\n\t\t\tonLoad(locales);\n\t\t}\n\t} else {\n\t\tif (typeof(sync) === 'undefined') {\n\t\t\tsync = true;\n\t\t}\n\t\tilib._load.listAvailableFiles(sync, function(manifest) {\n\t\t\tif (manifest) {\n\t\t\t\tfor (var dir in manifest) {\n\t\t\t\t\tvar filelist = manifest[dir];\n\t\t\t\t\tfor (var i = 0; i < filelist.length; i++) {\n\t\t\t\t\t\tif (filelist[i].length > 15 && filelist[i].substr(-15) === \"localeinfo.json\") {\n\t\t\t\t\t\t\tlocales.push(filelist[i].substring(0,filelist[i].length-16).replace(/\\//g, \"-\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (onLoad && typeof(onLoad) === 'function') {\n\t\t\t\tonLoad(locales);\n\t\t\t}\n\t\t});\n\t}\n\treturn locales;\n};\n\nmodule.exports = Locale;\n","/*\n * Utils.js - Core utility routines\n * \n * Copyright © 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// !depends ilib.js Locale.js JSUtils.js\n\nvar ilib = require(\"./ilib.js\");\nvar Locale = require(\"./Locale.js\");\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Utils = {};\n\n/**\n * Find and merge all the locale data for a particular prefix in the given locale\n * and return it as a single javascript object. This merges the data in the \n * correct order:\n * \n * <ol>\n * <li>shared data (usually English)\n * <li>data for language\n * <li>data for language + region\n * <li>data for language + region + script\n * <li>data for language + region + script + variant\n * </ol>\n * \n * It is okay for any of the above to be missing. This function will just skip the \n * missing data. However, if everything except the shared data is missing, this \n * function returns undefined, allowing the caller to go and dynamically load the\n * data instead.\n * \n * @static\n * @param {string} prefix prefix under ilib.data of the data to merge\n * @param {Locale} locale locale of the data being sought\n * @param {boolean=} replaceArrays if true, replace the array elements in object1 with those in object2.\n * If false, concatenate array elements in object1 with items in object2.\n * @param {boolean=} returnOne if true, only return the most locale-specific data. If false,\n * merge all the relevant locale data together.\n * @return {Object?} the merged locale data\n */\nUtils.mergeLocData = function (prefix, locale, replaceArrays, returnOne) {\n\tvar data = undefined;\n\tvar loc = locale || new Locale();\n\tvar foundLocaleData = false;\n\tvar property = prefix;\n\tvar mostSpecific;\n\n\tdata = ilib.data[prefix] || {};\n\n\tmostSpecific = data;\n\n\tif (loc.getLanguage()) {\n\t\tproperty = prefix + '_' + loc.getLanguage();\n\t\tif (ilib.data[property]) {\n\t\t\tfoundLocaleData = true;\n\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\tmostSpecific = ilib.data[property];\n\t\t}\n\t}\n\t\n\tif (loc.getRegion()) {\n\t\tproperty = prefix + '_' + loc.getRegion();\n\t\tif (ilib.data[property]) {\n\t\t\tfoundLocaleData = true;\n\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\tmostSpecific = ilib.data[property];\n\t\t}\n\t}\n\t\n\tif (loc.getLanguage()) {\n\t\tproperty = prefix + '_' + loc.getLanguage();\n\t\t\n\t\tif (loc.getScript()) {\n\t\t\tproperty = prefix + '_' + loc.getLanguage() + '_' + loc.getScript();\n\t\t\tif (ilib.data[property]) {\n\t\t\t\tfoundLocaleData = true;\n\t\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\t\tmostSpecific = ilib.data[property];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (loc.getRegion()) {\n\t\t\tproperty = prefix + '_' + loc.getLanguage() + '_' + loc.getRegion();\n\t\t\tif (ilib.data[property]) {\n\t\t\t\tfoundLocaleData = true;\n\t\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\t\tmostSpecific = ilib.data[property];\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tif (loc.getRegion() && loc.getVariant()) {\n\t\tproperty = prefix + '_' + loc.getLanguage() + '_' + loc.getVariant();\n\t\tif (ilib.data[property]) {\n\t\t\tfoundLocaleData = true;\n\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\tmostSpecific = ilib.data[property];\n\t\t}\n\t}\n\n\tif (loc.getLanguage() && loc.getScript() && loc.getRegion()) {\n\t\tproperty = prefix + '_' + loc.getLanguage() + '_' + loc.getScript() + '_' + loc.getRegion();\n\t\tif (ilib.data[property]) {\n\t\t\tfoundLocaleData = true;\n\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\tmostSpecific = ilib.data[property];\n\t\t}\n\t}\n\n\tif (loc.getLanguage() && loc.getRegion() && loc.getVariant()) {\n\t\tproperty = prefix + '_' + loc.getLanguage() + '_' + loc.getRegion() + '_' + loc.getVariant();\n\t\tif (ilib.data[property]) {\n\t\t\tfoundLocaleData = true;\n\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\tmostSpecific = ilib.data[property];\n\t\t}\n\t}\n\n\tif (loc.getLanguage() && loc.getScript() && loc.getRegion() && loc.getVariant()) {\n\t\tproperty = prefix + '_' + loc.getLanguage() + '_' + loc.getScript() + '_' + loc.getRegion() + '_' + loc.getVariant();\n\t\tif (ilib.data[property]) {\n\t\t\tfoundLocaleData = true;\n\t\t\tdata = JSUtils.merge(data, ilib.data[property], replaceArrays);\n\t\t\tmostSpecific = ilib.data[property];\n\t\t}\n\t}\n\t\n\treturn foundLocaleData ? (returnOne ? mostSpecific : data) : undefined;\n};\n\n/**\n * Return an array of relative path names for the\n * files that represent the data for the given locale.<p>\n * \n * Note that to prevent the situation where a directory for\n * a language exists next to the directory for a region where\n * the language code and region code differ only by case, the \n * plain region directories are located under the special \n * \"undefined\" language directory which has the ISO code \"und\".\n * The reason is that some platforms have case-insensitive \n * file systems, and you cannot have 2 directories with the \n * same name which only differ by case. For example, \"es\" is\n * the ISO 639 code for the language \"Spanish\" and \"ES\" is\n * the ISO 3166 code for the region \"Spain\", so both the\n * directories cannot exist underneath \"locale\". The region\n * therefore will be loaded from \"und/ES\" instead.<p>  \n * \n * <h4>Variations</h4>\n * \n * With only language and region specified, the following\n * sequence of paths will be generated:<p>\n * \n * <pre>\n * language\n * und/region\n * language/region\n * </pre>\n * \n * With only language and script specified:<p>\n * \n * <pre>\n * language\n * language/script\n * </pre>\n * \n * With only script and region specified:<p>\n * \n * <pre>\n * und/region  \n * </pre>\n * \n * With only region and variant specified:<p>\n * \n * <pre>\n * und/region\n * region/variant\n * </pre>\n * \n * With only language, script, and region specified:<p>\n * \n * <pre>\n * language\n * und/region\n * language/script\n * language/region\n * language/script/region\n * </pre>\n * \n * With only language, region, and variant specified:<p>\n * \n * <pre>\n * language\n * und/region\n * language/region\n * region/variant\n * language/region/variant\n * </pre>\n * \n * With all parts specified:<p>\n * \n * <pre>\n * language\n * und/region\n * language/script\n * language/region\n * region/variant\n * language/script/region\n * language/region/variant\n * language/script/region/variant\n * </pre>\n * \n * @static\n * @param {Locale} locale load the files for this locale\n * @param {string?} name the file name of each file to load without\n * any path\n * @return {Array.<string>} An array of relative path names\n * for the files that contain the locale data\n */\nUtils.getLocFiles = function(locale, name) {\n\tvar dir = \"\";\n\tvar files = [];\n\tvar filename = name || \"resources.json\";\n\tvar loc = locale || new Locale();\n\t\n\tvar language = loc.getLanguage();\n\tvar region = loc.getRegion();\n\tvar script = loc.getScript();\n\tvar variant = loc.getVariant();\n\t\n\tfiles.push(filename); // generic shared file\n\t\n\tif (language) {\n\t\tdir = language + \"/\";\n\t\tfiles.push(dir + filename);\n\t}\n\t\n\tif (region) {\n\t\tdir = \"und/\" + region + \"/\";\n\t\tfiles.push(dir + filename);\n\t}\n\t\n\tif (language) {\n\t\tif (script) {\n\t\t\tdir = language + \"/\" + script + \"/\";\n\t\t\tfiles.push(dir + filename);\n\t\t}\n\t\tif (region) {\n\t\t\tdir = language + \"/\" + region + \"/\";\n\t\t\tfiles.push(dir + filename);\n\t\t}\n\t}\n\t\n\tif (region && variant) {\n\t\tdir = \"und/\" + region + \"/\" + variant + \"/\";\n\t\tfiles.push(dir + filename);\n\t}\n\n\tif (language && script && region) {\n\t\tdir = language + \"/\" + script + \"/\" + region + \"/\";\n\t\tfiles.push(dir + filename);\n\t}\n\n\tif (language && region && variant) {\n\t\tdir = language + \"/\" + region + \"/\" + variant + \"/\";\n\t\tfiles.push(dir + filename);\n\t}\n\n\tif (language && script && region && variant) {\n\t\tdir = language + \"/\" + script + \"/\" + region + \"/\" + variant + \"/\";\n\t\tfiles.push(dir + filename);\n\t}\n\t\n\treturn files;\n};\n\n/**\n * Load data using the new loader object or via the old function callback.\n * @static\n * @private\n */\nUtils._callLoadData = function (files, sync, params, callback) {\n\t// console.log(\"Utils._callLoadData called\");\n\tif (typeof(ilib._load) === 'function') {\n\t\t// console.log(\"Utils._callLoadData: calling as a regular function\");\n\t\treturn ilib._load(files, sync, params, callback);\n\t} else if (typeof(ilib._load) === 'object' && typeof(ilib._load.loadFiles) === 'function') {\n\t\t// console.log(\"Utils._callLoadData: calling as an object\");\n\t\treturn ilib._load.loadFiles(files, sync, params, callback);\n\t}\n\t\n\t// console.log(\"Utils._callLoadData: not calling. Type is \" + typeof(ilib._load) + \" and instanceof says \" + (ilib._load instanceof Loader));\n\treturn undefined;\n};\n\n/**\n * Find locale data or load it in. If the data with the given name is preassembled, it will\n * find the data in ilib.data. If the data is not preassembled but there is a loader function,\n * this function will call it to load the data. Otherwise, the callback will be called with\n * undefined as the data. This function will create a cache under the given class object.\n * If data was successfully loaded, it will be set into the cache so that future access to \n * the same data for the same locale is much quicker.<p>\n * \n * The parameters can specify any of the following properties:<p>\n * \n * <ul>\n * <li><i>name</i> - String. The name of the file being loaded. Default: ResBundle.json\n * <li><i>object</i> - Object. The class attempting to load data. The cache is stored inside of here.\n * <li><i>locale</i> - Locale. The locale for which data is loaded. Default is the current locale.\n * <li><i>nonlocale</i> - boolean. If true, the data being loaded is not locale-specific.\n * <li><i>type</i> - String. Type of file to load. This can be \"json\" or \"other\" type. Default: \"json\" \n * <li><i>replace</i> - boolean. When merging json objects, this parameter controls whether to merge arrays\n * or have arrays replace each other. If true, arrays in child objects replace the arrays in parent \n * objects. When false, the arrays in child objects are concatenated with the arrays in parent objects.  \n * <li><i>loadParams</i> - Object. An object with parameters to pass to the loader function\n * <li><i>sync</i> - boolean. Whether or not to load the data synchronously\n * <li><i>callback</i> - function(?)=. callback Call back function to call when the data is available.\n * Data is not returned from this method, so a callback function is mandatory.\n * </ul>\n * \n * @static\n * @param {Object} params Parameters configuring how to load the files (see above)\n */\nUtils.loadData = function(params) {\n\tvar name = \"resources.json\",\n\t\tobject = undefined, \n\t\tlocale = new Locale(ilib.getLocale()), \n\t\tsync = false, \n\t\ttype = undefined,\n\t\tloadParams = {},\n\t\tcallback = undefined,\n\t\tnonlocale = false,\n\t\treplace = false,\n\t\tbasename;\n\t\n\tif (!params || typeof(params.callback) !== 'function') {\n\t\treturn;\n\t}\n\n\tif (params.name) {\n\t\tname = params.name;\n\t}\n\tif (params.object) {\n\t\tobject = params.object;\n\t}\n\tif (params.locale) {\n\t\tlocale = (typeof(params.locale) === 'string') ? new Locale(params.locale) : params.locale;\n\t}\t\t\t\n\tif (params.type) {\n\t\ttype = params.type;\n\t}\n\tif (params.loadParams) {\n\t\tloadParams = params.loadParams;\n\t}\n\tif (params.sync) {\n\t\tsync = params.sync;\n\t}\n\tif (params.nonlocale) {\n\t\tnonlocale = !!params.nonlocale;\n\t}\n\tif (typeof(params.replace) === 'boolean') {\n\t\treplace = params.replace;\n\t}\n\t\n\tcallback = params.callback;\n\t\n\tif (object && !object.cache) {\n\t\tobject.cache = {};\n\t}\n\t\n\tif (!type) {\n\t\tvar dot = name.lastIndexOf(\".\");\n\t\ttype = (dot !== -1) ? name.substring(dot+1) : \"text\";\n\t}\n\n\tvar spec = ((!nonlocale && locale.getSpec().replace(/-/g, '_')) || \"root\") + \",\" + name + \",\" + String(JSUtils.hashCode(loadParams));\n\tif (!object || typeof(object.cache[spec]) === 'undefined') {\n\t\tvar data, returnOne = (loadParams && loadParams.returnOne);\n\t\t\n\t\tif (type === \"json\") {\n\t\t\t// console.log(\"type is json\");\n\t\t\tbasename = name.substring(0, name.lastIndexOf(\".\"));\n\t\t\tif (nonlocale) {\n\t\t\t\tbasename = basename.replace(/\\//g, '.').replace(/[\\\\\\+\\-]/g, \"_\");\n\t\t\t\tdata = ilib.data[basename];\n\t\t\t} else {\n\t\t\t\tdata = Utils.mergeLocData(basename, locale, replace, returnOne);\n\t\t\t}\n\t\t\tif (data) {\n\t\t\t\t// console.log(\"found assembled data\");\n\t\t\t\tif (object) {\n\t\t\t\t\tobject.cache[spec] = data;\n\t\t\t\t}\n\t\t\t\tcallback(data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// console.log(\"ilib._load is \" + typeof(ilib._load));\n\t\tif (typeof(ilib._load) !== 'undefined') {\n\t\t\t// the data is not preassembled, so attempt to load it dynamically\n\t\t\tvar files = nonlocale ? [ name || \"resources.json\" ] : Utils.getLocFiles(locale, name);\n\t\t\tif (type !== \"json\") {\n\t\t\t\tloadParams.returnOne = true;\n\t\t\t}\n\t\t\t\n\t\t\tUtils._callLoadData(files, sync, loadParams, ilib.bind(this, function(arr) {\n\t\t\t\tif (type === \"json\") {\n\t\t\t\t\tdata = ilib.data[basename] || {};\n\t\t\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\t\t\tif (typeof(arr[i]) !== 'undefined') {\n\t\t\t\t\t\t\tdata = loadParams.returnOne ? arr[i] : JSUtils.merge(data, arr[i], replace);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tobject.cache[spec] = data;\n\t\t\t\t\t}\n\t\t\t\t\tcallback(data);\n\t\t\t\t} else {\n\t\t\t\t\tvar i = arr.length-1; \n\t\t\t\t\twhile (i > -1 && !arr[i]) {\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tif (i > -1) {\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tobject.cache[spec] = arr[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(arr[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t} else {\n\t\t\t// no data other than the generic shared data\n\t\t\tif (type === \"json\") {\n\t\t\t\tdata = ilib.data[basename];\n\t\t\t}\n\t\t\tif (object && data) {\n\t\t\t\tobject.cache[spec] = data;\n\t\t\t}\n\t\t\tcallback(data);\n\t\t}\n\t} else {\n\t\tcallback(object.cache[spec]);\n\t}\n};\n\nmodule.exports = Utils;","/*\n * LocaleInfo.js - Encode locale-specific defaults\n * \n * Copyright © 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// !depends ilib.js Locale.js Utils.js\n\n// !data localeinfo\n\nvar ilib = require(\"./ilib.js\");\nvar Utils = require(\"./Utils.js\");\nvar Locale = require(\"./Locale.js\");\n\n/**\n * @class\n * Create a new locale info instance. Locale info instances give information about\n * the default settings for a particular locale. These settings may be overridden\n * by various parts of the code, and should be used as a fall-back setting of last\n * resort. <p>\n * \n * The optional options object holds extra parameters if they are necessary. The\n * current list of supported options are:\n * \n * <ul>\n * <li><i>onLoad</i> - a callback function to call when the locale info object is fully \n * loaded. When the onLoad option is given, the localeinfo object will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the \n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two.\n * \n * <li><i>sync</i> - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while. \n *\n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * \n * If this copy of ilib is pre-assembled and all the data is already available, \n * or if the data was already previously loaded, then this constructor will call\n * the onLoad callback immediately when the initialization is done. \n * If the onLoad option is not given, this class will only attempt to load any\n * missing locale data synchronously.\n * \n * \n * @constructor\n * @see {ilib.setLoaderCallback} for information about registering a loader callback\n * function\n * @param {Locale|string=} locale the locale for which the info is sought, or undefined for\n * @param {Object=} options the locale for which the info is sought, or undefined for\n * the current locale\n */\nvar LocaleInfo = function(locale, options) {\n\tvar sync = true,\n\t    loadParams = undefined;\n\t\n\t/* these are all the defaults. Essentially, en-US */\n\t/**\n\t  @private \n\t  @type {{\n\t\tscripts:Array.<string>,\n\t\ttimezone:string,\n\t\tunits:string,\n\t\tcalendar:string,\n\t\tclock:string,\n\t\tcurrency:string,\n\t\tfirstDayOfWeek:number,\n\t\tweekendStart:number,\n\t\tweekendEnd:number,\n\t\tmeridiems:string,\n\t\tunitfmt: {long:string,short:string},\n\t\tnumfmt:Object.<{\n\t\t\tcurrencyFormats:Object.<{common:string,commonNegative:string,iso:string,isoNegative:string}>,\n\t\t\tscript:string,\n\t\t\tdecimalChar:string,\n\t\t\tgroupChar:string,\n\t\t\tprigroupSize:number,\n\t\t\tsecgroupSize:number,\n\t\t\tnegativenumFmt:string,\n\t\t\tpctFmt:string,\n\t\t\tnegativepctFmt:string,\n\t\t\tpctChar:string,\n\t\t\troundingMode:string,\n\t\t\texponential:string,\n\t\t\tdigits:string\n\t\t}>\n\t  }}\n\t*/\n\tthis.info = LocaleInfo.defaultInfo;\n\t\n\tswitch (typeof(locale)) {\n\t\tcase \"string\":\n\t\t\tthis.locale = new Locale(locale);\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase \"undefined\":\n\t\t\tthis.locale = new Locale();\n\t\t\tbreak;\n\t\tcase \"object\":\n\t\t\tthis.locale = locale;\n\t\t\tbreak;\n\t}\n\t\n\tif (options) {\n\t\tif (typeof(options.sync) !== 'undefined') {\n\t\t\tsync = (options.sync == true);\n\t\t}\n\t\t\n\t\tif (typeof(options.loadParams) !== 'undefined') {\n\t\t\tloadParams = options.loadParams;\n\t\t}\n\t}\n\n\tif (!LocaleInfo.cache) {\n\t\tLocaleInfo.cache = {};\n\t}\n\n\tUtils.loadData({\n\t\tobject: LocaleInfo, \n\t\tlocale: this.locale, \n\t\tname: \"localeinfo.json\", \n\t\tsync: sync, \n\t\tloadParams: loadParams, \n\t\tcallback: ilib.bind(this, function (info) {\n\t\t\tif (!info) {\n\t\t\t\tinfo = LocaleInfo.defaultInfo;\n\t\t\t\tvar spec = this.locale.getSpec().replace(/-/g, \"_\");\n\t\t\t\tLocaleInfo.cache[spec] = info;\n\t\t\t}\n\t\t\tthis.info = info;\n\t\t\tif (options && typeof(options.onLoad) === 'function') {\n\t\t\t\toptions.onLoad(this);\n\t\t\t}\n\t\t})\n\t});\n};\n\nLocaleInfo.defaultInfo = /** @type {{\n\tscripts:Array.<string>,\n\ttimezone:string,\n\tunits:string,\n\tcalendar:string,\n\tclock:string,\n\tcurrency:string,\n\tfirstDayOfWeek:number,\n\tweekendStart:number,\n\tweekendEnd:number,\n\tmeridiems:string,\n\tunitfmt: {long:string,short:string},\n\tnumfmt:Object.<{\n\t\tcurrencyFormats:Object.<{\n\t\t\tcommon:string,\n\t\t\tcommonNegative:string,\n\t\t\tiso:string,\n\t\t\tisoNegative:string\n\t\t}>,\n\t\tscript:string,\n\t\tdecimalChar:string,\n\t\tgroupChar:string,\n\t\tprigroupSize:number,\n\t\tsecgroupSize:number,\n\t\tnegativenumFmt:string,\n\t\tpctFmt:string,\n\t\tnegativepctFmt:string,\n\t\tpctChar:string,\n\t\troundingMode:string,\n\t\texponential:string,\n\t\tdigits:string\n\t}>\n}}*/ ilib.data.localeinfo;\nLocaleInfo.defaultInfo = LocaleInfo.defaultInfo || {\n\t\"scripts\": [\"Latn\"],\n    \"timezone\": \"Etc/UTC\",\n    \"units\": \"metric\",\n    \"calendar\": \"gregorian\",\n    \"clock\": \"24\",\n    \"currency\": \"USD\",\n    \"firstDayOfWeek\": 1,\n    \"meridiems\": \"gregorian\",\n    \"numfmt\": {\n        \"currencyFormats\": {\n            \"common\": \"{s}{n}\",\n            \"commonNegative\": \"{s}-{n}\",\n            \"iso\": \"{s}{n}\",\n            \"isoNegative\": \"{s}-{n}\"\n        },\n        \"script\": \"Latn\",\n        \"decimalChar\": \",\",\n        \"groupChar\": \".\",\n        \"prigroupSize\": 3,\n        \"secgroupSize\": 0,\n        \"pctFmt\": \"{n}%\",\n        \"negativepctFmt\": \"-{n}%\",\n        \"pctChar\": \"%\",\n        \"roundingMode\": \"halfdown\",\n        \"exponential\": \"e\",\n        \"digits\": \"\"\n    }\n};\n\nLocaleInfo.prototype = {\n    /**\n     * Return the name of the locale's language in English.\n     * @returns {string} the name of the locale's language in English\n     */\n    getLanguageName: function () {\n    \treturn this.info[\"language.name\"];\t\n    },\n    \n    /**\n     * Return the name of the locale's region in English. If the locale\n     * has no region, this returns undefined.\n     * \n     * @returns {string|undefined} the name of the locale's region in English\n     */\n    getRegionName: function () {\n    \treturn this.info[\"region.name\"];\t\n    },\n\n    /**\n\t * Return whether this locale commonly uses the 12- or the 24-hour clock.\n\t *  \n\t * @returns {string} \"12\" if the locale commonly uses a 12-hour clock, or \"24\"\n\t * if the locale commonly uses a 24-hour clock. \n\t */\n\tgetClock: function() {\n\t\treturn this.info.clock;\n\t},\n\n\t/**\n\t * Return the locale that this info object was created with.\n\t * @returns {Locale} The locale spec of the locale used to construct this info instance\n\t */\n\tgetLocale: function () {\n\t\treturn this.locale;\n\t},\n\t\n\t/**\n\t * Return the name of the measuring system that is commonly used in the given locale.\n\t * Valid values are \"uscustomary\", \"imperial\", and \"metric\".\n\t * \n\t * @returns {string} The name of the measuring system commonly used in the locale\n\t */\n\tgetUnits: function () {\n\t\treturn this.info.units;\n\t},\n        \n        getUnitFormat: function () {\n                return this.info.unitfmt;\n        },\n\t\n\t/**\n\t * Return the name of the calendar that is commonly used in the given locale.\n\t * \n\t * @returns {string} The name of the calendar commonly used in the locale\n\t */\n\tgetCalendar: function () {\n\t\treturn this.info.calendar;\n\t},\n\t\n\t/**\n\t * Return the day of week that starts weeks in the current locale. Days are still\n\t * numbered the standard way with 0 for Sunday through 6 for Saturday, but calendars \n\t * should be displayed and weeks calculated with the day of week returned from this \n\t * function as the first day of the week.\n\t * \n\t * @returns {number} the day of the week that starts weeks in the current locale.\n\t */\n\tgetFirstDayOfWeek: function () {\n\t\treturn this.info.firstDayOfWeek;\n\t},\n\t\n\t/**\n\t * Return the day of week that starts weekend in the current locale. Days are still\n\t * numbered the standard way with 0 for Sunday through 6 for Saturday.\n\t * \n\t * @returns {number} the day of the week that starts weeks in the current locale.\n\t */\n\tgetWeekEndStart: function () {\n\t\treturn this.info.weekendStart;\n\t},\n\n\t/**\n\t * Return the day of week that starts weekend in the current locale. Days are still\n\t * numbered the standard way with 0 for Sunday through 6 for Saturday.\n\t * \n\t * @returns {number} the day of the week that starts weeks in the current locale.\n\t */\n\tgetWeekEndEnd: function () {\n\t\treturn this.info.weekendEnd;\n\t},\n\n\t/**\n\t * Return the default time zone for this locale. Many locales span across multiple\n\t * time zones. In this case, the time zone with the largest population is chosen\n\t * to represent the locale. This is obviously not that accurate, but then again,\n\t * this method's return value should only be used as a default anyways.\n\t * @returns {string} the default time zone for this locale.\n\t */\n\tgetTimeZone: function () {\n\t\treturn this.info.timezone;\n\t},\n\t\n\t/**\n\t * Return the decimal separator for formatted numbers in this locale.\n\t * @returns {string} the decimal separator char\n\t */\n\tgetDecimalSeparator: function () {\n\t\treturn this.info.numfmt.decimalChar;\n\t},\n\t\n\t/**\n\t * Return the decimal separator for formatted numbers in this locale for native script.\n\t * @returns {string} the decimal separator char\n\t */\n\tgetNativeDecimalSeparator: function () {\n\t\treturn (this.info.native_numfmt && this.info.native_numfmt.decimalChar) || this.info.numfmt.decimalChar;\n\t},\n\t\n\t/**\n\t * Return the separator character used to separate groups of digits on the \n\t * integer side of the decimal character.\n\t * @returns {string} the grouping separator char\n\t */\n\tgetGroupingSeparator: function () {\n\t\treturn this.info.numfmt.groupChar;\n\t},\n\n\t/**\n\t * Return the separator character used to separate groups of digits on the \n\t * integer side of the decimal character for the native script if present other than the default script.\n\t * @returns {string} the grouping separator char\n\t */\n\tgetNativeGroupingSeparator: function () {\n\t\treturn (this.info.native_numfmt && this.info.native_numfmt.groupChar) || this.info.numfmt.groupChar;\n\t},\n\t\n\t/**\n\t * Return the minimum number of digits grouped together on the integer side \n\t * for the first (primary) group. \n\t * In western European cultures, groupings are in 1000s, so the number of digits\n\t * is 3. \n\t * @returns {number} the number of digits in a primary grouping, or 0 for no grouping\n\t */\n\tgetPrimaryGroupingDigits: function () {\n\t\treturn (typeof(this.info.numfmt.prigroupSize) !== 'undefined' && this.info.numfmt.prigroupSize) || 0;\n\t},\n\n\t/**\n\t * Return the minimum number of digits grouped together on the integer side\n\t * for the second or more (secondary) group.<p>\n\t *   \n\t * In western European cultures, all groupings are by 1000s, so the secondary\n\t * size should be 0 because there is no secondary size. In general, if this \n\t * method returns 0, then all groupings are of the primary size.<p> \n\t * \n\t * For some other cultures, the first grouping (primary)\n\t * is 3 and any subsequent groupings (secondary) are two. So, 100000 would be\n\t * written as: \"1,00,000\".\n\t * \n\t * @returns {number} the number of digits in a secondary grouping, or 0 for no \n\t * secondary grouping. \n\t */\n\tgetSecondaryGroupingDigits: function () {\n\t\treturn this.info.numfmt.secgroupSize || 0;\n\t},\n\n\t/**\n\t * Return the format template used to format percentages in this locale.\n\t * @returns {string} the format template for formatting percentages\n\t */\n\tgetPercentageFormat: function () {\n\t\treturn this.info.numfmt.pctFmt;\n\t},\n\n\t/**\n\t * Return the format template used to format percentages in this locale\n\t * with negative amounts.\n\t * @returns {string} the format template for formatting percentages\n\t */\n\tgetNegativePercentageFormat: function () {\n\t\treturn this.info.numfmt.negativepctFmt;\n\t},\n\n\t/**\n\t * Return the symbol used for percentages in this locale.\n\t * @returns {string} the symbol used for percentages in this locale\n\t */\n\tgetPercentageSymbol: function () {\n\t\treturn this.info.numfmt.pctChar || \"%\";\n\t},\n\n\t/**\n\t * Return the symbol used for exponential in this locale.\n\t * @returns {string} the symbol used for exponential in this locale\n\t */\n\tgetExponential: function () {\n\t\treturn this.info.numfmt.exponential;\n\t},\n\n\t/**\n\t * Return the symbol used for exponential in this locale for native script.\n\t * @returns {string} the symbol used for exponential in this locale for native script\n\t */\n\tgetNativeExponential: function () {\n\t\treturn (this.info.native_numfmt && this.info.native_numfmt.exponential) || this.info.numfmt.exponential;\n\t},\n\n\t/**\n\t * Return the symbol used for percentages in this locale for native script.\n\t * @returns {string} the symbol used for percentages in this locale for native script\n\t */\n\tgetNativePercentageSymbol: function () {\n\t\treturn (this.info.native_numfmt && this.info.native_numfmt.pctChar) || this.info.numfmt.pctChar || \"%\";\n\t\n\t},\n\t/**\n\t * Return the format template used to format negative numbers in this locale.\n\t * @returns {string} the format template for formatting negative numbers\n\t */\n\tgetNegativeNumberFormat: function () { \n\t\treturn this.info.numfmt.negativenumFmt;\n\t},\n\t\n\t/**\n\t * Return an object containing the format templates for formatting currencies\n\t * in this locale. The object has a number of properties in it that each are\n\t * a particular style of format. Normally, this contains a \"common\" and an \"iso\"\n\t * style, but may contain others in the future.\n\t * @returns {Object} an object containing the format templates for currencies\n\t */\n\tgetCurrencyFormats: function () {\n\t\treturn this.info.numfmt.currencyFormats;\n\t},\n\t\n\t/**\n\t * Return the currency that is legal in the locale, or which is most commonly \n\t * used in regular commerce.\n\t * @returns {string} the ISO 4217 code for the currency of this locale\n\t */\n\tgetCurrency: function () {\n\t\treturn this.info.currency;\n\t},\n\t\n\t/**\n\t * Return a string that describes the style of digits used by this locale.\n\t * Possible return values are:\n\t * <ul>\n\t * <li><i>western</i> - uses the regular western 10-based digits 0 through 9\n\t * <li><i>optional</i> - native 10-based digits exist, but in modern usage,\n\t * this locale most often uses western digits\n\t * <li><i>native</i> - native 10-based native digits exist and are used\n\t * regularly by this locale\n\t * <li><i>custom</i> - uses native digits by default that are not 10-based\n\t * </ul>\n\t * @returns {string} string that describes the style of digits used in this locale\n\t */\n\tgetDigitsStyle: function () {\n\t\tif (this.info.numfmt.useNative) {\n\t\t\treturn \"native\";\n\t\t}\n\t\tif (typeof(this.info.native_numfmt) !== 'undefined') {\n\t\t\treturn \"optional\";\n\t\t}\n\t\treturn \"western\";\n\t},\n\t\n\t/**\n\t * Return the digits of the default script if they are defined.\n\t * If not defined, the default should be the regular \"Arabic numerals\"\n\t * used in the Latin script. (0-9)\n\t * @returns {string|undefined} the digits used in the default script \n\t */\n\tgetDigits: function () {\n\t\treturn this.info.numfmt.digits;\n\t},\n\t\n\t/**\n\t * Return the digits of the native script if they are defined. \n\t * @returns {string|undefined} the digits used in the default script \n\t */\n\tgetNativeDigits: function () {\n\t\treturn (this.info.numfmt.useNative && this.info.numfmt.digits) || (this.info.native_numfmt && this.info.native_numfmt.digits);\n\t},\n\t\n\t/**\n\t * If this locale typically uses a different type of rounding for numeric\n\t * formatting other than halfdown, especially for currency, then it can be \n\t * specified in the localeinfo. If the locale uses the default, then this \n\t * method returns undefined. The locale's rounding method overrides the \n\t * rounding method for the currency itself, which can sometimes shared \n\t * between various locales so it is less specific.\n\t * @returns {string} the name of the rounding mode typically used in this\n\t * locale, or \"halfdown\" if the locale does not override the default\n\t */\n\tgetRoundingMode: function () {\n\t\treturn this.info.numfmt.roundingMode;\n\t},\n\t\n\t/**\n\t * Return the default script used to write text in the language of this \n\t * locale. Text for most languages is written in only one script, but there\n\t * are some languages where the text can be written in a number of scripts,\n\t * depending on a variety of things such as the region, ethnicity, religion, \n\t * etc. of the author. This method returns the default script for the\n\t * locale, in which the language is most commonly written.<p> \n\t * \n\t * The script is returned as an ISO 15924 4-letter code.\n\t * \n\t * @returns {string} the ISO 15924 code for the default script used to write\n\t * text in this locale \n\t */\n\tgetDefaultScript: function() {\n\t\treturn (this.info.scripts) ? this.info.scripts[0] : \"Latn\";\n\t},\n\t\n\t/**\n\t * Return the script used for the current locale. If the current locale\n\t * explicitly defines a script, then this script is returned. If not, then \n\t * the default script for the locale is returned.\n\t * \n\t * @see LocaleInfo.getDefaultScript\n\t * @returns {string} the ISO 15924 code for the script used to write\n\t * text in this locale\n\t */\n\tgetScript: function() {\n\t\treturn this.locale.getScript() || this.getDefaultScript(); \n\t},\n\t\n\t/**\n\t * Return an array of script codes which are used to write text in the current\n\t * language. Text for most languages is written in only one script, but there\n\t * are some languages where the text can be written in a number of scripts,\n\t * depending on a variety of things such as the region, ethnicity, religion, \n\t * etc. of the author. This method returns an array of script codes in which \n\t * the language is commonly written.\n\t * \n\t * @returns {Array.<string>} an array of ISO 15924 codes for the scripts used \n\t * to write text in this language\n\t */\n\tgetAllScripts: function() {\n\t\treturn this.info.scripts || [\"Latn\"];\n\t},\n\t\n\t/**\n\t * Return the default style of meridiems used in this locale. Meridiems are \n\t * times of day like AM/PM. In a few locales with some calendars, for example\n\t * Amharic/Ethiopia using the Ethiopic calendar, the times of day may be\n\t * split into different segments than simple AM/PM as in the Gregorian \n\t * calendar. Only a few locales are like that. For most locales, formatting \n\t * a Gregorian date will use the regular Gregorian AM/PM meridiems.\n\t *  \n\t * @returns {string} the default meridiems style used in this locale. Possible\n\t * values are \"gregorian\", \"chinese\", and \"ethiopic\"\n\t */\n\tgetMeridiemsStyle: function () {\n\t\treturn this.info.meridiems || \"gregorian\";\n\t}\t\n};\n\nmodule.exports = LocaleInfo;\n","/*\n * IString.js - ilib string subclass definition\n * \n * Copyright © 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// !depends ilib.js Utils.js Locale.js MathUtils.js\n\n// !data plurals\n\nvar ilib = require(\"./ilib.js\");\nvar Utils = require(\"./Utils.js\");\nvar MathUtils = require(\"./MathUtils.js\");\nvar Locale = require(\"./Locale.js\");\n\n/**\n * @class\n * Create a new ilib string instance. This string inherits from and\n * extends the Javascript String class. It can be\n * used almost anywhere that a normal Javascript string is used, though in\n * some instances you will need to call the {@link #toString} method when\n * a built-in Javascript string is needed. The formatting methods are \n * methods that are not in the intrinsic String class and are most useful\n * when localizing strings in an app or web site in combination with \n * the ResBundle class.<p>\n * \n * This class is named IString (\"ilib string\") so as not to conflict with the \n * built-in Javascript String class.\n * \n * @constructor\n * @param {string|IString=} string initialize this instance with this string \n */\nvar IString = function (string) {\n\tif (typeof(string) === 'object') {\n\t\tif (string instanceof IString) {\n\t\t\tthis.str = string.str;\t\n\t\t} else {\n\t\t\tthis.str = string.toString();\n\t\t}\n\t} else if (typeof(string) === 'string') {\n\t\tthis.str = new String(string);\n\t} else {\n\t\tthis.str = \"\";\n\t}\n\tthis.length = this.str.length;\n\tthis.cpLength = -1;\n\tthis.localeSpec = ilib.getLocale();\n};\n\n/**\n * Return true if the given character is a Unicode surrogate character,\n * either high or low.\n * \n * @private\n * @static\n * @param {string} ch character to check\n * @return {boolean} true if the character is a surrogate\n */\nIString._isSurrogate = function (ch) {\n\tvar n = ch.charCodeAt(0);\n\treturn ((n >= 0xDC00 && n <= 0xDFFF) || (n >= 0xD800 && n <= 0xDBFF));\n};\n\n/**\n * Convert a UCS-4 code point to a Javascript string. The codepoint can be any valid \n * UCS-4 Unicode character, including supplementary characters. Standard Javascript\n * only supports supplementary characters using the UTF-16 encoding, which has \n * values in the range 0x0000-0xFFFF. String.fromCharCode() will only\n * give you a string containing 16-bit characters, and will not properly convert \n * the code point for a supplementary character (which has a value > 0xFFFF) into \n * two UTF-16 surrogate characters. Instead, it will just just give you whatever\n * single character happens to be the same as your code point modulo 0x10000, which\n * is almost never what you want.<p> \n * \n * Similarly, that means if you use String.charCodeAt()\n * you will only retrieve a 16-bit value, which may possibly be a single\n * surrogate character that is part of a surrogate pair representing a character\n * in the supplementary plane. It will not give you a code point. Use \n * IString.codePointAt() to access code points in a string, or use \n * an iterator to walk through the code points in a string. \n * \n * @static\n * @param {number} codepoint UCS-4 code point to convert to a character\n * @return {string} a string containing the character represented by the codepoint\n */\nIString.fromCodePoint = function (codepoint) {\n\tif (codepoint < 0x10000) {\n\t\treturn String.fromCharCode(codepoint);\n\t} else {\n\t\tvar high = Math.floor(codepoint / 0x10000) - 1;\n\t\tvar low = codepoint & 0xFFFF;\n\t\t\n\t\treturn String.fromCharCode(0xD800 | ((high & 0x000F) << 6) |  ((low & 0xFC00) >> 10)) +\n\t\t\tString.fromCharCode(0xDC00 | (low & 0x3FF));\n\t}\n};\n\n/**\n * Convert the character or the surrogate pair at the given\n * index into the intrinsic Javascript string to a Unicode \n * UCS-4 code point.\n * \n * @param {string} str string to get the code point from\n * @param {number} index index into the string\n * @return {number} code point of the character at the\n * given index into the string\n */\nIString.toCodePoint = function(str, index) {\n\tif (!str || str.length === 0) {\n\t\treturn -1;\n\t}\n\tvar code = -1, high = str.charCodeAt(index);\n\tif (high >= 0xD800 && high <= 0xDBFF) {\n\t\tif (str.length > index+1) {\n\t\t\tvar low = str.charCodeAt(index+1);\n\t\t\tif (low >= 0xDC00 && low <= 0xDFFF) {\n\t\t\t\tcode = (((high & 0x3C0) >> 6) + 1) << 16 |\n\t\t\t\t\t(((high & 0x3F) << 10) | (low & 0x3FF));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcode = high;\n\t}\n\t\n\treturn code;\n};\n\n/**\n * Load the plural the definitions of plurals for the locale.\n * @param {boolean=} sync\n * @param {Locale|string=} locale\n * @param {Object=} loadParams\n * @param {function(*)=} onLoad\n */\nIString.loadPlurals = function (sync, locale, loadParams, onLoad) {\n\tvar loc;\n\tif (locale) {\n\t\tloc = (typeof(locale) === 'string') ? new Locale(locale) : locale;\n\t} else {\n\t\tloc = new Locale(ilib.getLocale());\n\t}\n\tvar spec = loc.getLanguage();\n\tif (!ilib.data[\"plurals_\" + spec]) {\n\t\tUtils.loadData({\n\t\t\tname: \"plurals.json\",\n\t\t\tobject: IString,\n\t\t\tlocale: loc,\n\t\t\tsync: sync,\n\t\t\tloadParams: loadParams,\n\t\t\tcallback: /** @type function(Object=):undefined */ ilib.bind(this, /** @type function() */ function(plurals) {\n\t\t\t\tif (!plurals) {\n\t\t\t\t\tIString.cache[spec] = {};\n\t\t\t\t}\n\t\t\t\tilib.data[\"plurals_\" + spec] = plurals || {};\n\t\t\t\tif (onLoad && typeof(onLoad) === 'function') {\n\t\t\t\t\tonLoad(ilib.data[\"plurals_\" + spec]);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t} else {\n\t\tif (onLoad && typeof(onLoad) === 'function') {\n\t\t\tonLoad(ilib.data[\"plurals_\" + spec]);\n\t\t}\n\t}\n};\n\n/**\n * @private\n * @static\n */\nIString._fncs = {\n\t/**\n\t * @private\n\t * @param {Object} obj\n\t * @return {string|undefined}\n\t */\n\tfirstProp: function (obj) {\n\t\tfor (var p in obj) {\n\t\t\tif (p && obj[p]) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\treturn undefined; // should never get here\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} obj\n\t * @param {number} n\n\t * @return {?}\n\t */\n\tgetValue: function (obj, n) {\n\t\tif (typeof(obj) === 'object') {\n\t\t\tvar subrule = IString._fncs.firstProp(obj);\n\t\t\treturn IString._fncs[subrule](obj[subrule], n);\n\t\t} else if (typeof(obj) === 'string') {\n\t\t\treturn n;\n\t\t} else {\n\t\t\treturn obj;\n\t\t}\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {number} n\n\t * @param {Array.<number|Array.<number>>} range\n\t * @return {boolean}\n\t */\n\tmatchRangeContinuous: function(n, range) {\n\t\tfor (var num in range) {\n\t\t\tif (typeof(num) !== 'undefined' && typeof(range[num]) !== 'undefined') {\n\t\t\t\tvar obj = /** @type {Object|null|undefined} */ range[num];\n\t\t\t\tif (typeof(obj) === 'number') {\n\t\t\t\t\tif (n === range[num]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (Object.prototype.toString.call(obj) === '[object Array]') {\n\t\t\t\t\tif (n >= obj[0] && n <= obj[1]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * @private\n\t * @param {number} n\n\t * @param {Array.<number|Array.<number>>} range\n\t * @return {boolean}\n\t */\n\tmatchRange: function(n, range) {\n\t\tif (Math.floor(n) !== n) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IString._fncs.matchRangeContinuous(n, range);\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\tis: function(rule, n) {\n\t\tvar left = IString._fncs.getValue(rule[0], n);\n\t\tvar right = IString._fncs.getValue(rule[1], n);\n\t\treturn left == right;\n\t\t// return IString._fncs.getValue(rule[0]) == IString._fncs.getValue(rule[1]);\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\tisnot: function(rule, n) {\n\t\treturn IString._fncs.getValue(rule[0], n) != IString._fncs.getValue(rule[1], n);\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\tinrange: function(rule, n) {\n\t\treturn IString._fncs.matchRange(IString._fncs.getValue(rule[0], n), rule[1]);\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\tnotin: function(rule, n) {\n\t\treturn !IString._fncs.matchRange(IString._fncs.getValue(rule[0], n), rule[1]);\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\twithin: function(rule, n) {\n\t\treturn IString._fncs.matchRangeContinuous(IString._fncs.getValue(rule[0], n), rule[1]);\t\t\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {number}\n\t */\n\tmod: function(rule, n) {\n\t\treturn MathUtils.mod(IString._fncs.getValue(rule[0], n), IString._fncs.getValue(rule[1], n));\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {number}\n\t */\n\tn: function(rule, n) {\n\t\treturn n;\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\tor: function(rule, n) {\n\t\treturn IString._fncs.getValue(rule[0], n) || IString._fncs.getValue(rule[1], n);\n\t},\n\t\n\t/**\n\t * @private\n\t * @param {Object} rule\n\t * @param {number} n\n\t * @return {boolean}\n\t */\n\tand: function(rule, n) {\n\t\treturn IString._fncs.getValue(rule[0], n) && IString._fncs.getValue(rule[1], n);\n\t}\n};\n\nIString.prototype = {\n\t/**\n\t * Return the length of this string in characters. This function defers to the regular\n\t * Javascript string class in order to perform the length function. Please note that this\n\t * method is a real method, whereas the length property of Javascript strings is \n\t * implemented by native code and appears as a property.<p>\n\t * \n\t * Example:\n\t * \n\t * <pre>\n\t * var str = new IString(\"this is a string\");\n\t * console.log(\"String is \" + str._length() + \" characters long.\");\n\t * </pre>\n\t * @private\n\t */\n\t_length: function () {\n\t\treturn this.str.length;\n\t},\n\t\n\t/**\n\t * Format this string instance as a message, replacing the parameters with \n\t * the given values.<p>\n\t * \n\t * The string can contain any text that a regular Javascript string can\n\t * contain. Replacement parameters have the syntax:\n\t * \n\t * <pre>\n\t * {name}\n\t * </pre>\n\t * \n\t * Where \"name\" can be any string surrounded by curly brackets. The value of \n\t * \"name\" is taken from the parameters argument.<p>\n\t * \n\t * Example:\n\t * \n\t * <pre>\n\t * var str = new IString(\"There are {num} objects.\");\n\t * console.log(str.format({\n\t *   num: 12\n\t * });\n\t * </pre>\n\t * \n\t * Would give the output:\n\t * \n\t * <pre>\n\t * There are 12 objects.\n\t * </pre>\n\t * \n\t * If a property is missing from the parameter block, the replacement\n\t * parameter substring is left untouched in the string, and a different\n\t * set of parameters may be applied a second time. This way, different\n\t * parts of the code may format different parts of the message that they\n\t * happen to know about.<p>\n\t * \n\t * Example:\n\t * \n\t * <pre>\n\t * var str = new IString(\"There are {num} objects in the {container}.\");\n\t * console.log(str.format({\n\t *   num: 12\n\t * });\n\t * </pre>\n\t * \n\t * Would give the output:<p>\n\t * \n\t * <pre>\n\t * There are 12 objects in the {container}.\n\t * </pre>\n\t * \n\t * The result can then be formatted again with a different parameter block that\n\t * specifies a value for the container property.\n\t * \n\t * @param params a Javascript object containing values for the replacement \n\t * parameters in the current string\n\t * @return a new IString instance with as many replacement parameters filled\n\t * out as possible with real values.\n\t */\n\tformat: function (params) {\n\t\tvar formatted = this.str;\n\t\tif (params) {\n\t\t\tvar regex;\n\t\t\tfor (var p in params) {\n\t\t\t\tif (typeof(params[p]) !== 'undefined') {\n\t\t\t\t\tregex = new RegExp(\"\\{\"+p+\"\\}\", \"g\");\n\t\t\t\t\tformatted = formatted.replace(regex, params[p]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn formatted.toString();\n\t},\n\t\n\t/**\n\t * Format a string as one of a choice of strings dependent on the value of\n\t * a particular argument index.<p>\n\t * \n\t * The syntax of the choice string is as follows. The string contains a\n\t * series of choices separated by a vertical bar character \"|\". Each choice\n\t * has a value or range of values to match followed by a hash character \"#\"\n\t * followed by the string to use if the variable matches the criteria.<p>\n\t * \n\t * Example string:\n\t * \n\t * <pre>\n\t * var num = 2;\n\t * var str = new IString(\"0#There are no objects.|1#There is one object.|2#There are {number} objects.\");\n\t * console.log(str.formatChoice(num, {\n\t *   number: num\n\t * }));\n\t * </pre>\n\t * \n\t * Gives the output:\n\t * \n\t * <pre>\n\t * \"There are 2 objects.\"\n\t * </pre>\n\t * \n\t * The strings to format may contain replacement variables that will be formatted\n\t * using the format() method above and the params argument as a source of values\n\t * to use while formatting those variables.<p>\n\t * \n\t * If the criterion for a particular choice is empty, that choice will be used\n\t * as the default one for use when none of the other choice's criteria match.<p>\n\t * \n\t * Example string:\n\t * \n\t * <pre>\n\t * var num = 22;\n\t * var str = new IString(\"0#There are no objects.|1#There is one object.|#There are {number} objects.\");\n\t * console.log(str.formatChoice(num, {\n\t *   number: num\n\t * }));\n\t * </pre>\n\t * \n\t * Gives the output:\n\t * \n\t * <pre>\n\t * \"There are 22 objects.\"\n\t * </pre>\n\t * \n\t * If multiple choice patterns can match a given argument index, the first one \n\t * encountered in the string will be used. If no choice patterns match the \n\t * argument index, then the default choice will be used. If there is no default\n\t * choice defined, then this method will return an empty string.<p>\n\t * \n\t * <b>Special Syntax</b><p>\n\t * \n\t * For any choice format string, all of the patterns in the string should be\n\t * of a single type: numeric, boolean, or string/regexp. The type of the \n\t * patterns is determined by the type of the argument index parameter.<p>\n\t * \n\t * If the argument index is numeric, then some special syntax can be used \n\t * in the patterns to match numeric ranges.<p>\n\t * \n\t * <ul>\n\t * <li><i>&gt;x</i> - match any number that is greater than x \n\t * <li><i>&gt;=x</i> - match any number that is greater than or equal to x\n\t * <li><i>&lt;x</i> - match any number that is less than x\n\t * <li><i>&lt;=x</i> - match any number that is less than or equal to x\n\t * <li><i>start-end</i> - match any number in the range [start,end)\n\t * <li><i>zero</i> - match any number in the class \"zero\". (See below for\n\t * a description of number classes.)\n\t * <li><i>one</i> - match any number in the class \"one\"\n\t * <li><i>two</i> - match any number in the class \"two\"\n\t * <li><i>few</i> - match any number in the class \"few\"\n\t * <li><i>many</i> - match any number in the class \"many\"\n\t * </ul>\n\t * \n\t * A number class defines a set of numbers that receive a particular syntax\n\t * in the strings. For example, in Slovenian, integers ending in the digit\n\t * \"1\" are in the \"one\" class, including 1, 21, 31, ... 101, 111, etc.\n\t * Similarly, integers ending in the digit \"2\" are in the \"two\" class. \n\t * Integers ending in the digits \"3\" or \"4\" are in the \"few\" class, and\n\t * every other integer is handled by the default string.<p>\n\t * \n\t * The definition of what numbers are included in a class is locale-dependent.\n\t * They are defined in the data file plurals.json. If your string is in a\n\t * different locale than the default for ilib, you should call the setLocale()\n\t * method of the string instance before calling this method.<p> \n\t * \n\t * <b>Other Pattern Types</b><p>\n\t * \n\t * If the argument index is a boolean, the string values \"true\" and \"false\" \n\t * may appear as the choice patterns.<p>\n\t * \n\t * If the argument index is of type string, then the choice patterns may contain\n\t * regular expressions, or static strings as degenerate regexps.\n\t * \n\t * @param {*} argIndex The index into the choice array of the current parameter\n\t * @param {Object} params The hash of parameter values that replace the replacement \n\t * variables in the string\n\t * @throws \"syntax error in choice format pattern: \" if there is a syntax error\n\t * @return {string} the formatted string\n\t */\n\tformatChoice: function(argIndex, params) {\n\t\tvar choices = this.str.split(\"|\");\n\t\tvar type = typeof(argIndex);\n\t\tvar limits = [];\n\t\tvar strings = [];\n\t\tvar i;\n\t\tvar parts;\n\t\tvar limit;\n\t\tvar arg;\n\t\tvar result = undefined;\n\t\tvar defaultCase = \"\";\n\t\n\t\tif (this.str.length === 0) {\n\t\t\t// nothing to do\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\t// first parse all the choices\n\t\tfor (i = 0; i < choices.length; i++) {\t\t\n\t\t\tparts = choices[i].split(\"#\");\t\t\n\t\t\tif (parts.length > 2) {\n\t\t\t\tlimits[i] = parts[0];\n\t\t\t\tparts = parts.shift();\t\t\t\n\t\t\t\tstrings[i] = parts.join(\"#\");\n\t\t\t} else if (parts.length === 2) {\n\t\t\t\tlimits[i] = parts[0];\n\t\t\t\tstrings[i] = parts[1];\n\t\t\t} else {\n\t\t\t\t// syntax error\n\t\t\t\tthrow \"syntax error in choice format pattern: \" + choices[i];\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\t// then apply the argument index\n\t\tfor (i = 0; i < limits.length; i++) {\n\t\t\tif (limits[i].length === 0) {\n\t\t\t\t// this is default case\n\t\t\t\tdefaultCase = new IString(strings[i]);\t\t\t\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\targ = parseInt(argIndex, 10);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (limits[i].substring(0,2) === \"<=\") {\t\t\t\t\t\t\n\t\t\t\t\t\t\tlimit = parseFloat(limits[i].substring(2));\n\t\t\t\t\t\t\tif (arg <= limit) {\n\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (limits[i].substring(0,2) === \">=\") {\t\t\t\t\t\t\n\t\t\t\t\t\t\tlimit = parseFloat(limits[i].substring(2));\n\t\t\t\t\t\t\tif (arg >= limit) {\n\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (limits[i].charAt(0) === \"<\") {\t\t\t\t\t\t\n\t\t\t\t\t\t\tlimit = parseFloat(limits[i].substring(1));\n\t\t\t\t\t\t\tif (arg < limit) {\n\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (limits[i].charAt(0) === \">\") {\t\t\t\t\t\t\n\t\t\t\t\t\t\tlimit = parseFloat(limits[i].substring(1));\n\t\t\t\t\t\t\tif (arg > limit) {\n\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.locale = this.locale || new Locale(this.localeSpec);\n\t\t\t\t\t\t\tswitch (limits[i]) {\n\t\t\t\t\t\t\t\tcase \"zero\":\n\t\t\t\t\t\t\t\tcase \"one\":\n\t\t\t\t\t\t\t\tcase \"two\":\n\t\t\t\t\t\t\t\tcase \"few\":\n\t\t\t\t\t\t\t\tcase \"many\":\n\t\t\t\t\t\t\t\t\t// CLDR locale-dependent number classes\n\t\t\t\t\t\t\t\t\tvar ruleset = ilib.data[\"plurals_\" + this.locale.getLanguage()];\n\t\t\t\t\t\t\t\t\tif (ruleset) {\n\t\t\t\t\t\t\t\t\t\tvar rule = ruleset[limits[i]];\n\t\t\t\t\t\t\t\t\t\tif (IString._fncs.getValue(rule, arg)) {\n\t\t\t\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tvar dash = limits[i].indexOf(\"-\");\n\t\t\t\t\t\t\t\t\tif (dash !== -1) {\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// range\n\t\t\t\t\t\t\t\t\t\tvar start = limits[i].substring(0, dash);\n\t\t\t\t\t\t\t\t\t\tvar end = limits[i].substring(dash+1);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (arg >= parseInt(start, 10) && arg <= parseInt(end, 10)) {\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (arg === parseInt(limits[i], 10)) {\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// exact amount\n\t\t\t\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'boolean':\t\t\t\t\t\n\t\t\t\t\t\tif (limits[i] === \"true\" && argIndex === true) {\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t} else if (limits[i] === \"false\" && argIndex === false) {\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'string':\t\t\t\t\t\n\t\t\t\t\t\tvar regexp = new RegExp(limits[i], \"i\");\n\t\t\t\t\t\tif (regexp.test(argIndex)) {\n\t\t\t\t\t\t\tresult = new IString(strings[i]);\n\t\t\t\t\t\t\ti = limits.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tthrow \"syntax error: fmtChoice parameter for the argument index cannot be an object\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!result) {\t\t\n\t\t\tresult = defaultCase || new IString(\"\");\n\t\t}\n\t\t\n\t\tresult = result.format(params);\n\t\t\n\t\treturn result.toString();\n\t},\n\t\n\t// delegates\n\t/**\n\t * Same as String.toString()\n\t * @return {string} this instance as regular Javascript string\n\t */\n\ttoString: function () {\n\t\treturn this.str.toString();\n\t},\n\t\n\t/**\n\t * Same as String.valueOf()\n\t * @return {string} this instance as a regular Javascript string\n\t */\n\tvalueOf: function () {\n\t\treturn this.str.valueOf();\n\t},\n\t\n\t/**\n\t * Same as String.charAt()\n\t * @param {number} index the index of the character being sought\n\t * @return {IString} the character at the given index\n\t */\n\tcharAt: function(index) {\n\t\treturn new IString(this.str.charAt(index));\n\t},\n\t\n\t/**\n\t * Same as String.charCodeAt(). This only reports on \n\t * 2-byte UCS-2 Unicode values, and does not take into\n\t * account supplementary characters encoded in UTF-16.\n\t * If you would like to take account of those characters,\n\t * use codePointAt() instead.\n\t * @param {number} index the index of the character being sought\n\t * @return {number} the character code of the character at the \n\t * given index in the string \n\t */\n\tcharCodeAt: function(index) {\n\t\treturn this.str.charCodeAt(index);\n\t},\n\t\n\t/**\n\t * Same as String.concat()\n\t * @param {string} strings strings to concatenate to the current one\n\t * @return {IString} a concatenation of the given strings\n\t */\n\tconcat: function(strings) {\n\t\treturn new IString(this.str.concat(strings));\n\t},\n\t\n\t/**\n\t * Same as String.indexOf()\n\t * @param {string} searchValue string to search for\n\t * @param {number} start index into the string to start searching, or\n\t * undefined to search the entire string\n\t * @return {number} index into the string of the string being sought,\n\t * or -1 if the string is not found \n\t */\n\tindexOf: function(searchValue, start) {\n\t\treturn this.str.indexOf(searchValue, start);\n\t},\n\t\n\t/**\n\t * Same as String.lastIndexOf()\n\t * @param {string} searchValue string to search for\n\t * @param {number} start index into the string to start searching, or\n\t * undefined to search the entire string\n\t * @return {number} index into the string of the string being sought,\n\t * or -1 if the string is not found \n\t */\n\tlastIndexOf: function(searchValue, start) {\n\t\treturn this.str.lastIndexOf(searchValue, start);\n\t},\n\t\n\t/**\n\t * Same as String.match()\n\t * @param {string} regexp the regular expression to match\n\t * @return {Array.<string>} an array of matches\n\t */\n\tmatch: function(regexp) {\n\t\treturn this.str.match(regexp);\n\t},\n\t\n\t/**\n\t * Same as String.replace()\n\t * @param {string} searchValue a regular expression to search for\n\t * @param {string} newValue the string to replace the matches with\n\t * @return {IString} a new string with all the matches replaced\n\t * with the new value\n\t */\n\treplace: function(searchValue, newValue) {\n\t\treturn new IString(this.str.replace(searchValue, newValue));\n\t},\n\t\n\t/**\n\t * Same as String.search()\n\t * @param {string} regexp the regular expression to search for\n\t * @return {number} position of the match, or -1 for no match\n\t */\n\tsearch: function(regexp) {\n\t\treturn this.str.search(regexp);\n\t},\n\t\n\t/**\n\t * Same as String.slice()\n\t * @param {number} start first character to include in the string\n\t * @param {number} end include all characters up to, but not including\n\t * the end character\n\t * @return {IString} a slice of the current string\n\t */\n\tslice: function(start, end) {\n\t\treturn new IString(this.str.slice(start, end));\n\t},\n\t\n\t/**\n\t * Same as String.split()\n\t * @param {string} separator regular expression to match to find\n\t * separations between the parts of the text\n\t * @param {number} limit maximum number of items in the final \n\t * output array. Any items beyond that limit will be ignored.\n\t * @return {Array.<string>} the parts of the current string split \n\t * by the separator\n\t */\n\tsplit: function(separator, limit) {\n\t\treturn this.str.split(separator, limit);\n\t},\n\t\n\t/**\n\t * Same as String.substr()\n\t * @param {number} start the index of the character that should \n\t * begin the returned substring\n\t * @param {number} length the number of characters to return after\n\t * the start character.\n\t * @return {IString} the requested substring \n\t */\n\tsubstr: function(start, length) {\n\t\tvar plat = ilib._getPlatform();\n\t\tif (plat === \"qt\" || plat === \"rhino\" || plat === \"trireme\") {\n\t\t\t// qt and rhino have a broken implementation of substr(), so\n\t\t\t// work around it\n\t\t\tif (typeof(length) === \"undefined\") {\n\t\t\t\tlength = this.str.length - start;\n\t\t\t}\n\t\t}\n\t\treturn new IString(this.str.substr(start, length));\n\t},\n\t\n\t/**\n\t * Same as String.substring()\n\t * @param {number} from the index of the character that should \n\t * begin the returned substring\n\t * @param {number} to the index where to stop the extraction. If\n\t * omitted, extracts the rest of the string\n\t * @return {IString} the requested substring \n\t */\n\tsubstring: function(from, to) {\n\t\treturn this.str.substring(from, to);\n\t},\n\t\n\t/**\n\t * Same as String.toLowerCase(). Note that this method is\n\t * not locale-sensitive. \n\t * @return {IString} a string with the first character\n\t * lower-cased\n\t */\n\ttoLowerCase: function() {\n\t\treturn this.str.toLowerCase();\n\t},\n\t\n\t/**\n\t * Same as String.toUpperCase(). Note that this method is\n\t * not locale-sensitive. Use toLocaleUpperCase() instead\n\t * to get locale-sensitive behaviour. \n\t * @return {IString} a string with the first character\n\t * upper-cased\n\t */\n\ttoUpperCase: function() {\n\t\treturn this.str.toUpperCase();\n\t},\n\t\n\t/**\n\t * Convert the character or the surrogate pair at the given\n\t * index into the string to a Unicode UCS-4 code point.\n\t * @protected\n\t * @param {number} index index into the string\n\t * @return {number} code point of the character at the\n\t * given index into the string\n\t */\n\t_toCodePoint: function (index) {\n\t\treturn IString.toCodePoint(this.str, index);\n\t},\n\t\n\t/**\n\t * Call the callback with each character in the string one at \n\t * a time, taking care to step through the surrogate pairs in \n\t * the UTF-16 encoding properly.<p>\n\t * \n\t * The standard Javascript String's charAt() method only\n\t * returns a particular 16-bit character in the \n\t * UTF-16 encoding scheme.\n\t * If the index to charAt() is pointing to a low- or \n\t * high-surrogate character,\n\t * it will return the surrogate character rather \n\t * than the the character \n\t * in the supplementary planes that the two surrogates together \n\t * encode. This function will call the callback with the full\n\t * character, making sure to join two  \n\t * surrogates into one character in the supplementary planes\n\t * where necessary.<p>\n\t * \n\t * @param {function(string)} callback a callback function to call with each\n\t * full character in the current string\n\t */\n\tforEach: function(callback) {\n\t\tif (typeof(callback) === 'function') {\n\t\t\tvar it = this.charIterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tcallback(it.next());\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Call the callback with each numeric code point in the string one at \n\t * a time, taking care to step through the surrogate pairs in \n\t * the UTF-16 encoding properly.<p>\n\t * \n\t * The standard Javascript String's charCodeAt() method only\n\t * returns information about a particular 16-bit character in the \n\t * UTF-16 encoding scheme.\n\t * If the index to charCodeAt() is pointing to a low- or \n\t * high-surrogate character,\n\t * it will return the code point of the surrogate character rather \n\t * than the code point of the character \n\t * in the supplementary planes that the two surrogates together \n\t * encode. This function will call the callback with the full\n\t * code point of each character, making sure to join two  \n\t * surrogates into one code point in the supplementary planes.<p>\n\t * \n\t * @param {function(string)} callback a callback function to call with each\n\t * code point in the current string\n\t */\n\tforEachCodePoint: function(callback) {\n\t\tif (typeof(callback) === 'function') {\n\t\t\tvar it = this.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tcallback(it.next());\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Return an iterator that will step through all of the characters\n\t * in the string one at a time and return their code points, taking \n\t * care to step through the surrogate pairs in UTF-16 encoding \n\t * properly.<p>\n\t * \n\t * The standard Javascript String's charCodeAt() method only\n\t * returns information about a particular 16-bit character in the \n\t * UTF-16 encoding scheme.\n\t * If the index is pointing to a low- or high-surrogate character,\n\t * it will return a code point of the surrogate character rather \n\t * than the code point of the character \n\t * in the supplementary planes that the two surrogates together \n\t * encode.<p>\n\t * \n\t * The iterator instance returned has two methods, hasNext() which\n\t * returns true if the iterator has more code points to iterate through,\n\t * and next() which returns the next code point as a number.<p>\n\t * \n\t * @return {Object} an iterator \n\t * that iterates through all the code points in the string\n\t */\n\titerator: function() {\n\t\t/**\n\t\t * @constructor\n\t\t */\n\t\tfunction _iterator (istring) {\n\t\t\tthis.index = 0;\n\t\t\tthis.hasNext = function () {\n\t\t\t\treturn (this.index < istring.str.length);\n\t\t\t};\n\t\t\tthis.next = function () {\n\t\t\t\tif (this.index < istring.str.length) {\n\t\t\t\t\tvar num = istring._toCodePoint(this.index);\n\t\t\t\t\tthis.index += ((num > 0xFFFF) ? 2 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tnum = -1;\n\t\t\t\t}\n\t\t\t\treturn num;\n\t\t\t};\n\t\t};\n\t\treturn new _iterator(this);\n\t},\n\n\t/**\n\t * Return an iterator that will step through all of the characters\n\t * in the string one at a time, taking \n\t * care to step through the surrogate pairs in UTF-16 encoding \n\t * properly.<p>\n\t * \n\t * The standard Javascript String's charAt() method only\n\t * returns information about a particular 16-bit character in the \n\t * UTF-16 encoding scheme.\n\t * If the index is pointing to a low- or high-surrogate character,\n\t * it will return that surrogate character rather \n\t * than the surrogate pair which represents a character \n\t * in the supplementary planes.<p>\n\t * \n\t * The iterator instance returned has two methods, hasNext() which\n\t * returns true if the iterator has more characters to iterate through,\n\t * and next() which returns the next character.<p>\n\t * \n\t * @return {Object} an iterator \n\t * that iterates through all the characters in the string\n\t */\n\tcharIterator: function() {\n\t\t/**\n\t\t * @constructor\n\t\t */\n\t\tfunction _chiterator (istring) {\n\t\t\tthis.index = 0;\n\t\t\tthis.hasNext = function () {\n\t\t\t\treturn (this.index < istring.str.length);\n\t\t\t};\n\t\t\tthis.next = function () {\n\t\t\t\tvar ch;\n\t\t\t\tif (this.index < istring.str.length) {\n\t\t\t\t\tch = istring.str.charAt(this.index);\n\t\t\t\t\tif (IString._isSurrogate(ch) && \n\t\t\t\t\t\t\tthis.index+1 < istring.str.length && \n\t\t\t\t\t\t\tIString._isSurrogate(istring.str.charAt(this.index+1))) {\n\t\t\t\t\t\tthis.index++;\n\t\t\t\t\t\tch += istring.str.charAt(this.index);\n\t\t\t\t\t}\n\t\t\t\t\tthis.index++;\n\t\t\t\t}\n\t\t\t\treturn ch;\n\t\t\t};\n\t\t};\n\t\treturn new _chiterator(this);\n\t},\n\t\n\t/**\n\t * Return the code point at the given index when the string is viewed \n\t * as an array of code points. If the index is beyond the end of the\n\t * array of code points or if the index is negative, -1 is returned.\n\t * @param {number} index index of the code point \n\t * @return {number} code point of the character at the given index into\n\t * the string\n\t */\n\tcodePointAt: function (index) {\n\t\tif (index < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar count,\n\t\t\tit = this.iterator(),\n\t\t\tch;\n\t\tfor (count = index; count >= 0 && it.hasNext(); count--) {\n\t\t\tch = it.next();\n\t\t}\n\t\treturn (count < 0) ? ch : -1;\n\t},\n\t\n\t/**\n\t * Set the locale to use when processing choice formats. The locale\n\t * affects how number classes are interpretted. In some cultures,\n\t * the limit \"few\" maps to \"any integer that ends in the digits 2 to 9\" and\n\t * in yet others, \"few\" maps to \"any integer that ends in the digits\n\t * 3 or 4\".\n\t * @param {Locale|string} locale locale to use when processing choice\n\t * formats with this string\n\t * @param {boolean=} sync [optional] whether to load the locale data synchronously \n\t * or not\n\t * @param {Object=} loadParams [optional] parameters to pass to the loader function\n\t * @param {function(*)=} onLoad [optional] function to call when the loading is done\n\t */\n\tsetLocale: function (locale, sync, loadParams, onLoad) {\n\t\tif (typeof(locale) === 'object') {\n\t\t\tthis.locale = locale;\n\t\t} else {\n\t\t\tthis.localeSpec = locale;\n\t\t\tthis.locale = new Locale(locale);\n\t\t}\n\t\t\n\t\tIString.loadPlurals(typeof(sync) !== 'undefined' ? sync : true, this.locale, loadParams, onLoad);\n\t},\n\n\t/**\n\t * Return the locale to use when processing choice formats. The locale\n\t * affects how number classes are interpretted. In some cultures,\n\t * the limit \"few\" maps to \"any integer that ends in the digits 2 to 9\" and\n\t * in yet others, \"few\" maps to \"any integer that ends in the digits\n\t * 3 or 4\".\n\t * @return {string} localespec to use when processing choice\n\t * formats with this string\n\t */\n\tgetLocale: function () {\n\t\treturn (this.locale ? this.locale.getSpec() : this.localeSpec) || ilib.getLocale();\n\t},\n\n\t/**\n\t * Return the number of code points in this string. This may be different\n\t * than the number of characters, as the UTF-16 encoding that Javascript\n\t * uses for its basis returns surrogate pairs separately. Two 2-byte \n\t * surrogate characters together make up one character/code point in \n\t * the supplementary character planes. If your string contains no\n\t * characters in the supplementary planes, this method will return the\n\t * same thing as the length() method.\n\t * @return {number} the number of code points in this string\n\t */\n\tcodePointLength: function () {\n\t\tif (this.cpLength === -1) {\n\t\t\tvar it = this.iterator();\n\t\t\tthis.cpLength = 0;\n\t\t\twhile (it.hasNext()) { \n\t\t\t\tthis.cpLength++;\n\t\t\t\tit.next();\n\t\t\t};\n\t\t}\n\t\treturn this.cpLength;\t\n\t}\n};\n\nmodule.exports = IString;","/*\n * ResBundle.js - Resource bundle definition\n * \n * Copyright © 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// !depends ilib.js Locale.js LocaleInfo.js IString.js Utils.js JSUtils.js\n\n// !data pseudomap\n\nvar ilib = require(\"./ilib.js\");\nvar Utils = require(\"./Utils.js\");\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IString = require(\"./IString.js\");\n\n/**\n * @class\n * Create a new resource bundle instance. The resource bundle loads strings\n * appropriate for a particular locale and provides them via the getString \n * method.<p>\n * \n * The options object may contain any (or none) of the following properties:\n * \n * <ul>\n * <li><i>locale</i> - The locale of the strings to load. If not specified, the default\n * locale is the the default for the web page or app in which the bundle is \n * being loaded.\n * \n * <li><i>name</i> - Base name of the resource bundle to load. If not specified the default\n * base name is \"resources\".\n * \n * <li><i>type</i> - Name the type of strings this bundle contains. Valid values are \n * \"xml\", \"html\", \"text\", or \"raw\". The default is \"text\". If the type is \"xml\" or \"html\",\n * then XML/HTML entities and tags are not pseudo-translated. During a real translation, \n * HTML character entities are translated to their corresponding characters in a source\n * string before looking that string up in the translations. Also, the characters \"<\", \">\",\n * and \"&\" are converted to entities again in the output, but characters are left as they\n * are. If the type is \"xml\", \"html\", or \"text\" types, then the replacement parameter names\n * are not pseudo-translated as well so that the output can be used for formatting with \n * the IString class. If the type is raw, all characters are pseudo-translated, \n * including replacement parameters as well as XML/HTML tags and entities.\n * \n * <li><i>lengthen</i> - when pseudo-translating the string, tell whether or not to \n * automatically lengthen the string to simulate \"long\" languages such as German\n * or French. This is a boolean value. Default is false.\n * \n * <li><i>missing</i> - what to do when a resource is missing. The choices are:\n * <ul>\n *   <li><i>source</i> - return the source string unchanged\n *   <li><i>pseudo</i> - return the pseudo-translated source string, translated to the\n *   script of the locale if the mapping is available, or just the default Latin \n *   pseudo-translation if not\n *   <li><i>empty</i> - return the empty string \n * </ul>\n * The default behaviour is the same as before, which is to return the source string\n * unchanged.\n * \n * <li><i>onLoad</i> - a callback function to call when the resources are fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the \n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two. \n * \n * <li>sync - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while. \n *\n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * \n * The locale option may be given as a locale spec string or as an \n * Locale object. If the locale option is not specified, then strings for\n * the default locale will be loaded.<p> \n * \n * The name option can be used to put groups of strings together in a\n * single bundle. The strings will then appear together in a JS object in\n * a JS file that can be included before the ilib.<p>\n * \n * A resource bundle with a particular name is actually a set of bundles\n * that are each specific to a language, a language plus a region, etc. \n * All bundles with the same base name should\n * contain the same set of source strings, but with different translations for \n * the given locale. The user of the bundle does not need to be aware of \n * the locale of the bundle, as long as it contains values for the strings \n * it needs.<p>\n * \n * Strings in bundles for a particular locale are inherited from parent bundles\n * that are more generic. In general, the hierarchy is as follows (from \n * least locale-specific to most locale-specific):\n * \n * <ol>\n * <li> language\n * <li> region\n * <li> language_script\n * <li> language_region\n * <li> region_variant\n * <li> language_script_region\n * <li> language_region_variant\n * <li> language_script_region_variant\n * </ol>\n * \n * That is, if the translation for a string does not exist in the current\n * locale, the more-generic parent locale is searched for the string. In the\n * worst case scenario, the string is not found in the base locale's strings. \n * In this case, the missing option guides this class on what to do. If\n * the missing option is \"source\", then the original source is returned as \n * the translation. If it is \"empty\", the empty string is returned. If it\n * is \"pseudo\", then the pseudo-translated string that is appropriate for\n * the default script of the locale is returned.<p> \n * \n * This allows developers to create code with new or changed strings in it and check in that\n * code without waiting for the translations to be done first. The translated\n * version of the app or web site will still function properly, but will show \n * a spurious untranslated string here and there until the translations are \n * done and also checked in.<p>   \n *  \n * The base is whatever language your developers use to code in. For\n * a German web site, strings in the source code may be written in German \n * for example. Often this base is English, as many web sites are coded in\n * English, but that is not required.<p>\n * \n * The strings can be extracted with the ilib localization tool (which will be\n * shipped at some future time.) Once the strings\n * have been translated, the set of translated files can be generated with the\n * same tool. The output from the tool can be used as input to the ResBundle\n * object. It is up to the web page or app to make sure the JS file that defines\n * the bundle is included before creating the ResBundle instance.<p>\n * \n * A special locale \"zxx-XX\" is used as the pseudo-translation locale because\n * zxx means \"no linguistic information\" in the ISO 639 standard, and the region \n * code XX is defined to be user-defined in the ISO 3166 standard. \n * Pseudo-translation is a locale where the translations are generated on\n * the fly based on the contents of the source string. Characters in the source \n * string are replaced with other characters and returned. \n * \n * Example. If the source string is:\n * \n * <pre>\n * \"This is a string\"\n * </pre>\n * \n * then the pseudo-translated version might look something like this: \n * \n * <pre>\n * \"Ţħïş ïş á şţřïñĝ\"\n * </pre>\n * <p>\n * \n * Pseudo-translation can be used to test that your app or web site is translatable\n * before an actual translation has happened. These bugs can then be fixed \n * before the translation starts, avoiding an explosion of bugs later when\n * each language's tester registers the same bug complaining that the same \n * string is not translated. When pseudo-localizing with\n * the Latin script, this allows the strings to be readable in the UI in the \n * source language (if somewhat funky-looking), \n * so that a tester can easily verify that the string is properly externalized \n * and loaded from a resource bundle without the need to be able to read a\n * foreign language.<p> \n * \n * If one of a list of script tags is given in the pseudo-locale specifier, then the\n * pseudo-localization can map characters to very rough transliterations of\n * characters in the given script. For example, zxx-Hebr-XX maps strings to\n * Hebrew characters, which can be used to test your UI in a right-to-left\n * language to catch bidi bugs before a translation is done. Currently, the\n * list of target scripts includes Hebrew (Hebr), Chinese Simplified Han (Hans),\n * and Cyrillic (Cyrl) with more to be added later. If no script is explicitly\n * specified in the locale spec, or if the script is not supported,\n * then the default mapping maps Latin base characters to accented versions of\n * those Latin characters as in the example above.\n *  \n * When the \"lengthen\" property is set to true in the options, the \n * pseudotranslation code will add digits to the end of the string to simulate\n * the lengthening that occurs when translating to other languages. The above \n * example will come out like this:\n * \n * <pre>\n * \"Ţħïş ïş á şţřïñĝ76543210\"\n * </pre>\n * \n * The string is lengthened according to the length of the source string. If\n * the source string is less than 20 characters long, the string is lengthened \n * by 50%. If the source string is 20-40 \n * characters long, the string is lengthened by 33%. If te string is greater\n * than 40 characters long, the string is lengthened by 20%.<p>\n * \n * The pseudotranslation always ends a string with the digit \"0\". If you do\n * not see the digit \"0\" in the UI for your app, you know that truncation\n * has occurred, and the number you see at the end of the string tells you \n * how many characters were truncated.<p>\n * \n * \n * @constructor\n * @param {?Object} options Options controlling how the bundle is created\n */\nvar ResBundle = function (options) {\n\tvar lookupLocale, spec;\n\t\n\tthis.locale = new Locale();\t// use the default locale\n\tthis.baseName = \"strings\";\n\tthis.type = \"text\";\n\tthis.loadParams = {};\n\tthis.missing = \"source\";\n\tthis.sync = true;\n\t\n\tif (options) {\n\t\tif (options.locale) {\n\t\t\tthis.locale = (typeof(options.locale) === 'string') ? \n\t\t\t\t\tnew Locale(options.locale) :\n\t\t\t\t\toptions.locale;\n\t\t}\n\t\tif (options.name) {\n\t\t\tthis.baseName = options.name;\n\t\t}\n\t\tif (options.type) {\n\t\t\tthis.type = options.type;\n\t\t}\n\t\tthis.lengthen = options.lengthen || false;\n\t\t\n\t\tif (typeof(options.sync) !== 'undefined') {\n\t\t\tthis.sync = (options.sync == true);\n\t\t}\n\t\t\n\t\tif (typeof(options.loadParams) !== 'undefined') {\n\t\t\tthis.loadParams = options.loadParams;\n\t\t}\n\t\tif (typeof(options.missing) !== 'undefined') {\n\t\t\tif (options.missing === \"pseudo\" || options.missing === \"empty\") {\n\t\t\t\tthis.missing = options.missing;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toptions = {};\n\t}\n\t\n\tthis.map = {};\n\n\tif (!ResBundle[this.baseName]) {\n\t\tResBundle[this.baseName] = {};\n\t}\n\n\tlookupLocale = this.locale.isPseudo() ? new Locale(\"en-US\") : this.locale;\n\n\tUtils.loadData({\n\t\tobject: ResBundle[this.baseName], \n\t\tlocale: lookupLocale, \n\t\tname: this.baseName + \".json\", \n\t\tsync: this.sync, \n\t\tloadParams: this.loadParams, \n\t\tcallback: ilib.bind(this, function (map) {\n\t\t\tif (!map) {\n\t\t\t\tmap = ilib.data[this.baseName] || {};\n\t\t\t\tspec = lookupLocale.getSpec().replace(/-/g, '_');\n\t\t\t\tResBundle[this.baseName].cache[spec] = map;\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t\tif (this.locale.isPseudo()) {\n\t\t\t\tif (!ResBundle.pseudomap) {\n\t\t\t\t\tResBundle.pseudomap = {};\n\t\t\t\t}\n\t\n\t\t\t\tthis._loadPseudo(this.locale, options.onLoad);\n\t\t\t} else if (this.missing === \"pseudo\") {\n\t\t\t\tif (!ResBundle.pseudomap) {\n\t\t\t\t\tResBundle.pseudomap = {};\n\t\t\t\t}\n\t\n\t\t\t\tnew LocaleInfo(this.locale, {\n\t\t\t\t\tsync: this.sync,\n\t\t\t\t\tloadParams: this.loadParams,\n\t\t\t\t\tonLoad: ilib.bind(this, function (li) {\n\t\t\t\t\t\tvar pseudoLocale = new Locale(\"zxx\", \"XX\", undefined, li.getDefaultScript());\n\t\t\t\t\t\tthis._loadPseudo(pseudoLocale, options.onLoad);\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (typeof(options.onLoad) === 'function') {\n\t\t\t\t\toptions.onLoad(this);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t});\n\n\t// console.log(\"Merged resources \" + this.locale.toString() + \" are: \" + JSON.stringify(this.map));\n\t//if (!this.locale.isPseudo() && JSUtils.isEmpty(this.map)) {\n\t//\tconsole.log(\"Resources for bundle \" + this.baseName + \" locale \" + this.locale.toString() + \" are not available.\");\n\t//}\n};\n\nResBundle.defaultPseudo = ilib.data.pseudomap || {\n\t\"a\": \"à\",\n\t\"e\": \"ë\",\n\t\"i\": \"í\",\n\t\"o\": \"õ\",\n\t\"u\": \"ü\",\n\t\"y\": \"ÿ\",\n\t\"A\": \"Ã\",\n\t\"E\": \"Ë\",\n\t\"I\": \"Ï\",\n\t\"O\": \"Ø\",\n\t\"U\": \"Ú\",\n\t\"Y\": \"Ŷ\"\n};\n\nResBundle.prototype = {\n    /**\n     * @protected\n     */\n    _loadPseudo: function (pseudoLocale, onLoad) {\n\t\tUtils.loadData({\n\t\t\tobject: ResBundle.pseudomap, \n\t\t\tlocale: pseudoLocale, \n\t\t\tname: \"pseudomap.json\", \n\t\t\tsync: this.sync, \n\t\t\tloadParams: this.loadParams, \n\t\t\tcallback: ilib.bind(this, function (map) {\n\t\t\t\tif (!map || JSUtils.isEmpty(map)) {\n\t\t\t\t\tmap = ResBundle.defaultPseudo;\n\t\t\t\t\tvar spec = pseudoLocale.getSpec().replace(/-/g, '_');\n\t\t\t\t\tResBundle.pseudomap.cache[spec] = map;\n\t\t\t\t}\n\t\t\t\tthis.pseudomap = map;\n\t\t\t\tif (typeof(onLoad) === 'function') {\n\t\t\t\t\tonLoad(this);\n\t\t\t\t}\t\n\t\t\t})\n\t\t});\n    },\n    \n\t/**\n\t * Return the locale of this resource bundle.\n\t * @return {Locale} the locale of this resource bundle object \n\t */\n\tgetLocale: function () {\n\t\treturn this.locale;\n\t},\n\t\n\t/**\n\t * Return the name of this resource bundle. This corresponds to the name option\n\t * given to the constructor.\n\t * @return {string} name of the the current instance\n\t */\n\tgetName: function () {\n\t\treturn this.baseName;\n\t},\n\t\n\t/**\n\t * Return the type of this resource bundle. This corresponds to the type option\n\t * given to the constructor.\n\t * @return {string} type of the the current instance\n\t */\n\tgetType: function () {\n\t\treturn this.type;\n\t},\n\n\t/*\n\t * @private\n\t * Pseudo-translate a string\n\t */\n\tpseudo: function (str) {\n\t\tif (!str) {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar ret = \"\", i;\n\t\tfor (i = 0; i < str.length; i++) {\n\t\t\tif (this.type !== \"raw\") {\n\t\t\t\tif (this.type === \"html\" || this.type === \"xml\") {\n\t\t\t\t\tif (str.charAt(i) === '<') {\n\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\twhile (i < str.length && str.charAt(i) !== '>') {\n\t\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < str.length) {\n\t\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str.charAt(i) === '&') {\n\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\twhile (i < str.length && str.charAt(i) !== ';' && str.charAt(i) !== ' ') {\n\t\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < str.length) {\n\t\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i < str.length) { \n\t\t\t\t\tif (str.charAt(i) === '{') {\n\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\twhile (i < str.length && str.charAt(i) !== '}') {\n\t\t\t\t\t\t\tret += str.charAt(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < str.length) {\n\t\t\t\t\t\t\tret += str.charAt(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret += this.pseudomap[str.charAt(i)] || str.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret += this.pseudomap[str.charAt(i)] || str.charAt(i);\n\t\t\t}\n\t\t}\n\t\tif (this.lengthen) {\n\t\t\tvar add;\n\t\t\tif (ret.length <= 20) {\n\t\t\t\tadd = Math.round(ret.length / 2);\n\t\t\t} else if (ret.length > 20 && ret.length <= 40) {\n\t\t\t\tadd = Math.round(ret.length / 3);\n\t\t\t} else {\n\t\t\t\tadd = Math.round(ret.length / 5);\n\t\t\t}\n\t\t\tfor (i = add-1; i >= 0; i--) {\n\t\t\t\tret += (i % 10);\n\t\t\t}\n\t\t}\n\t\tif (this.locale.getScript() === \"Hans\" || this.locale.getScript() === \"Hant\" ||\n\t\t\t\tthis.locale.getScript() === \"Hani\" ||\n\t\t\t\tthis.locale.getScript() === \"Hrkt\" || this.locale.getScript() === \"Jpan\" ||\n\t\t\t\tthis.locale.getScript() === \"Hira\" || this.locale.getScript() === \"Kana\" ) {\n\t\t\t// simulate Asian languages by getting rid of all the spaces\n\t\t\tret = ret.replace(/ /g, \"\");\n\t\t}\n\t\treturn ret;\n\t},\n\t\n\t/*\n\t * @private\n\t * Escape html characters in the output.\n\t */\n\tescapeXml: function (str) {\n\t\tstr = str.replace(/&/g, '&amp;');\n\t\tstr = str.replace(/</g, '&lt;');\n\t\tstr = str.replace(/>/g, '&gt;');\n\t\treturn str;\n\t},\n\n\t/*\n\t * @private\n\t * @param {string} str the string to unescape\n\t */\n\tunescapeXml: function (str) {\n\t\tstr = str.replace(/&amp;/g, '&');\n\t\tstr = str.replace(/&lt;/g, '<');\n\t\tstr = str.replace(/&gt;/g, '>');\n\t\treturn str;\n\t},\n\t\n\t/*\n\t * @private\n\t * Create a key name out of a source string. All this does so far is \n\t * compress sequences of white space into a single space on the assumption\n\t * that this doesn't really change the meaning of the string, and therefore\n\t * all such strings that compress to the same thing should share the same\n\t * translation.\n\t * @param {string} source the source string to make a key out of\n\t */\n\tmakeKey: function (source) {\n\t\tvar key = source.replace(/\\s+/gm, ' ');\n\t\treturn (this.type === \"xml\" || this.type === \"html\") ? this.unescapeXml(key) : key;\n\t},\n\t\n\t/**\n\t * Return a localized string. If the string is not found in the loaded set of\n\t * resources, the original source string is returned. If the key is not given,\n\t * then the source string itself is used as the key. In the case where the \n\t * source string is used as the key, the whitespace is compressed down to 1 space\n\t * each, and the whitespace at the beginning and end of the string is trimmed.<p>\n\t * \n\t * The escape mode specifies what type of output you are escaping the returned\n\t * string for. Modes are similar to the types: \n\t * \n\t * <ul>\n\t * <li>\"html\" -- prevents HTML injection by escaping the characters &lt &gt; and &amp;\n\t * <li>\"xml\" -- currently same as \"html\" mode\n\t * <li>\"js\" -- prevents breaking Javascript syntax by backslash escaping all quote and \n\t * double-quote characters\n\t * <li>\"attribute\" -- meant for HTML attribute values. Currently this is the same as\n\t * \"js\" escape mode.\n\t * <li>\"default\" -- use the type parameter from the constructor as the escape mode as well\n\t * <li>\"none\" or undefined -- no escaping at all.\n\t * </ul>\n\t * \n\t * The type parameter of the constructor specifies what type of strings this bundle\n\t * is operating upon. This allows pseudo-translation and automatic key generation\n\t * to happen properly by telling this class how to parse the string. The escape mode \n\t * for this method is different in that it specifies how this string will be used in \n\t * the calling code and therefore how to escape it properly.<p> \n\t * \n\t * For example, a section of Javascript code may be constructing an HTML snippet in a \n\t * string to add to the web page. In this case, the type parameter in the constructor should\n\t * be \"html\" so that the source string can be parsed properly, but the escape mode should\n\t * be \"js\" so that the output string can be used in Javascript without causing syntax\n\t * errors.\n\t * \n\t * @param {?string=} source the source string to translate\n\t * @param {?string=} key optional name of the key, if any\n\t * @param {?string=} escapeMode escape mode, if any\n\t * @return {IString|undefined} the translation of the given source/key or undefined \n\t * if the translation is not found and the source is undefined \n\t */\n\tgetString: function (source, key, escapeMode) {\n\t\tif (!source && !key) return new IString(\"\");\n\n\t\tvar trans;\n\t\tif (this.locale.isPseudo()) {\n\t\t\tvar str = source ? source : this.map[key];\n\t\t\ttrans = this.pseudo(str || key);\n\t\t} else {\n\t\t\tvar keyName = key || this.makeKey(source);\n\t\t\tif (typeof(this.map[keyName]) !== 'undefined') {\n\t\t\t\ttrans = this.map[keyName];\n\t\t\t} else if (this.missing === \"pseudo\") {\n\t\t\t\ttrans = this.pseudo(source || key);\n\t\t\t} else if (this.missing === \"empty\") {\n\t\t\t\ttrans = \"\";\n\t\t\t} else {\n\t\t\t\ttrans = source;\n\t\t\t}\n\t\t}\n\n\t\tif (escapeMode && escapeMode !== \"none\") {\n\t\t\tif (escapeMode == \"default\") {\n\t\t\t\tescapeMode = this.type;\n\t\t\t}\n\t\t\tif (escapeMode === \"xml\" || escapeMode === \"html\") {\n\t\t\t\ttrans = this.escapeXml(trans);\n\t\t\t} else if (escapeMode == \"js\" || escapeMode === \"attribute\") {\n\t\t\t\ttrans = trans.replace(/'/g, \"\\\\\\'\").replace(/\"/g, \"\\\\\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (trans === undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tvar ret = new IString(trans);\n\t\t\tret.setLocale(this.locale.getSpec(), true, this.loadParams); // no callback\n\t\t\treturn ret;\n\t\t}\n\t},\n\t\n\t/**\n\t * Return a localized string as a Javascript object. This does the same thing as\n\t * the getString() method, but it returns a regular Javascript string instead of\n\t * and IString instance. This means it cannot be formatted with the format()\n\t * method without being wrapped in an IString instance first.\n\t * \n\t * @param {?string=} source the source string to translate\n\t * @param {?string=} key optional name of the key, if any\n\t * @param {?string=} escapeMode escape mode, if any\n\t * @return {string|undefined} the translation of the given source/key or undefined \n\t * if the translation is not found and the source is undefined\n\t */\n\tgetStringJS: function(source, key, escapeMode) {\n\t\treturn this.getString(source, key, escapeMode).toString();\n\t},\n\t\n\t/**\n\t * Return true if the current bundle contains a translation for the given key and\n\t * source. The\n\t * getString method will always return a string for any given key and source \n\t * combination, so it cannot be used to tell if a translation exists. Either one\n\t * or both of the source and key must be specified. If both are not specified,\n\t * this method will return false.\n\t * \n\t * @param {?string=} source source string to look up\n\t * @param {?string=} key key to look up\n\t * @return {boolean} true if this bundle contains a translation for the key, and \n\t * false otherwise\n\t */\n\tcontainsKey: function(source, key) {\n\t\tif (typeof(source) === 'undefined' && typeof(key) === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar keyName = key || this.makeKey(source);\n\t\treturn typeof(this.map[keyName]) !== 'undefined';\n\t},\n\t\n\t/**\n\t * Return the merged resources as an entire object. When loading resources for a\n\t * locale that are not just a set of translated strings, but instead an entire \n\t * structured javascript object, you can gain access to that object via this call. This method\n\t * will ensure that all the of the parts of the object are correct for the locale.<p>\n\t * \n\t * For pre-assembled data, it starts by loading <i>ilib.data[name]</i>, where \n\t * <i>name</i> is the base name for this set of resources. Then, it successively \n\t * merges objects in the base data using progressively more locale-specific data. \n\t * It loads it in this order from <i>ilib.data</i>:\n\t * \n\t * <ol>\n\t * <li> language\n\t * <li> region\n\t * <li> language_script\n\t * <li> language_region\n\t * <li> region_variant\n\t * <li> language_script_region\n\t * <li> language_region_variant\n\t * <li> language_script_region_variant\n\t * </ol>\n\t * \n\t * For dynamically loaded data, the code attempts to load the same sequence as\n\t * above, but with slash path separators instead of underscores.<p>\n\t *  \n\t * Loading the resources this way allows the program to share resources between all\n\t * locales that share a common language, region, or script. As a \n\t * general rule-of-thumb, resources should be as generic as possible in order to\n\t * cover as many locales as possible.\n\t * \n\t * @return {Object} returns the object that is the basis for this resources instance\n\t */\n\tgetResObj: function () {\n\t\treturn this.map;\n\t}\n};\n\nmodule.exports = ResBundle;"]}